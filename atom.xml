<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lilyssh</title>
  
  <subtitle>lilyssh</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lilyssh.cn/"/>
  <updated>2020-04-25T15:50:29.836Z</updated>
  <id>https://lilyssh.cn/</id>
  
  <author>
    <name>lilyssh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>维修外星人差点被骗 凯旋门大厦A座10层D室 4001067088</title>
    <link href="https://lilyssh.cn/life/2-cheat/"/>
    <id>https://lilyssh.cn/life/2-cheat/</id>
    <published>2020-04-24T16:00:00.000Z</published>
    <updated>2020-04-25T15:50:29.836Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://resource.lilyssh.cn/pic/life/cheat.png" alt><br>外星人笔记本S键掉了，搜戴尔外星人官方售后电话，竟然搜到了这么个骗子网站<strong><a href="http://www.support-tj.com/alwm/" target="_blank" rel="noopener">http://www.support-tj.com/alwm/</a></strong>，看到上面写着电话：400-106-7088，就打电话到4001067088，客服让我到天津市河西区南京路66号凯旋门大厦A座10层D室（A10D）电话：022-23121350 17622628035来修，这边员工这个黑心啊，非说一个键坏了，就必须得换整套键盘，要1300块。我就又换了家问问，结果70块修好了。再打电话过去投诉时，问他们公司名字，死活不肯说，只说确实不是戴尔官方售后，只是综合服务中心，敢做不敢当是吧，行，我有的是办法去各大网站曝光你们的无耻行径。<br><img src="https://resource.lilyssh.cn/pic/life/don&#39;t_cheat.jpg" alt><br><img src="https://resource.lilyssh.cn/pic/life/zhang_xin.jpg" alt><br><img src="https://resource.lilyssh.cn/pic/life/angry.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://resource.lilyssh.cn/pic/life/cheat.png&quot; alt&gt;&lt;br&gt;外星人笔记本S键掉了，搜戴尔外星人官方售后电话，竟然搜到了这么个骗子网站&lt;strong&gt;&lt;a href=&quot;http://www.support
      
    
    </summary>
    
      <category term="小心受骗" scheme="https://lilyssh.cn/categories/%E5%B0%8F%E5%BF%83%E5%8F%97%E9%AA%97/"/>
    
    
      <category term="小心受骗" scheme="https://lilyssh.cn/tags/%E5%B0%8F%E5%BF%83%E5%8F%97%E9%AA%97/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://lilyssh.cn/zookeeper/1-zookeeper/"/>
    <id>https://lilyssh.cn/zookeeper/1-zookeeper/</id>
    <published>2020-03-03T16:00:00.000Z</published>
    <updated>2020-03-04T15:54:07.001Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/zookeeper/2-zookeeper/">https://lilyssh.cn/zookeeper/2-zookeeper/</a></p><a id="more"></a><h1 id="一、ZooKeeper是什么？"><a href="#一、ZooKeeper是什么？" class="headerlink" title="一、ZooKeeper是什么？"></a>一、ZooKeeper是什么？</h1><p>ZooKeeper是个开源的分布式系统的协调组件，用来协作多个任务。</p><h1 id="二、ZooKeeper能用来做什么？"><a href="#二、ZooKeeper能用来做什么？" class="headerlink" title="二、ZooKeeper能用来做什么？"></a>二、ZooKeeper能用来做什么？</h1><p>配置管理、名字服务、分布式锁、集群管理。</p><h1 id="三、为什么要使用ZooKeeper？"><a href="#三、为什么要使用ZooKeeper？" class="headerlink" title="三、为什么要使用ZooKeeper？"></a>三、为什么要使用ZooKeeper？</h1><p>使开发人员更多关注应用本身逻辑，而不是协同工作上，保证项目健壮性。<br>而且具有高容错性和可扩展性。</p><p>集群版<br>Zookeeper 集群中的角色<br>设计目的</p><h1 id="群首选举"><a href="#群首选举" class="headerlink" title="群首选举"></a>群首选举</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/zookeeper/2-zookeeper/&quot;&gt;https://lilyssh.cn/zookeeper/2-zookeeper/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ZooKeeper" scheme="https://lilyssh.cn/categories/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="https://lilyssh.cn/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>spring中用到的设计模式</title>
    <link href="https://lilyssh.cn/design-pattern/2-design-pattern-spring/"/>
    <id>https://lilyssh.cn/design-pattern/2-design-pattern-spring/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2019-12-13T15:47:58.711Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Spring IOC 工厂、单例、装饰器<br>Spring AOP 代理、观察者<br>Spring MVC 委派、适配器<br>Spring JDBC 模板方法</p><h2 id="1-、工厂模式"><a href="#1-、工厂模式" class="headerlink" title="1)、工厂模式"></a>1)、工厂模式</h2><p>BeanFactory</p><h2 id="2-、装饰器模式"><a href="#2-、装饰器模式" class="headerlink" title="2)、装饰器模式"></a>2)、装饰器模式</h2><p>BeanWrapper</p><h2 id="3-、代理模式"><a href="#3-、代理模式" class="headerlink" title="3)、代理模式"></a>3)、代理模式</h2><p>AopProxy</p><h2 id="4-、单例模式"><a href="#4-、单例模式" class="headerlink" title="4)、单例模式"></a>4)、单例模式</h2><p>ApplicationContext</p><h2 id="5-、委派模式"><a href="#5-、委派模式" class="headerlink" title="5)、委派模式"></a>5)、委派模式</h2><p>DispatcherServlet</p><h2 id="6-、策略模式"><a href="#6-、策略模式" class="headerlink" title="6)、策略模式"></a>6)、策略模式</h2><p>HandlerMapping</p><h2 id="7-、适配器模式"><a href="#7-、适配器模式" class="headerlink" title="7)、适配器模式"></a>7)、适配器模式</h2><p>HandlerAdapter</p><h2 id="8-、摸板方法模式"><a href="#8-、摸板方法模式" class="headerlink" title="8)、摸板方法模式"></a>8)、摸板方法模式</h2><p>JdbcTemplate</p><h2 id="9-、观察者模式"><a href="#9-、观察者模式" class="headerlink" title="9)、观察者模式"></a>9)、观察者模式</h2><p>ContextLoaderListener</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Spring IOC 工厂、单例、装饰器&lt;br&gt;Spring AOP 代理、观察者&lt;br&gt;Spring MVC 委派、适配器&lt;br&gt;Spring JDBC 模板方法&lt;/p&gt;
&lt;h2 id=&quot;1-、工厂模式&quot;&gt;&lt;a href=&quot;#1-、工厂
      
    
    </summary>
    
      <category term="设计模式" scheme="https://lilyssh.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilyssh.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://lilyssh.cn/design-pattern/1-design-pattern/"/>
    <id>https://lilyssh.cn/design-pattern/1-design-pattern/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2019-12-13T15:12:08.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、软件设计的原则"><a href="#1、软件设计的原则" class="headerlink" title="1、软件设计的原则"></a>1、软件设计的原则</h1><a id="more"></a><p>SOLID<br>|     |                               |             |<br>| :–:| :—————————: | :———: |<br>| SRP    | Simple Responsibility Pinciple | 单一责任原则 |<br>| OCP    | Open-Closed Principle | 开放封闭原则 |<br>| LSP    | Liskov Substitution Principle | 里氏替换原则 |<br>| ISP    | Interface Segregation Principle | 接口隔离原则 |<br>| DIP    | Dependence Inversion Principle | 依赖倒置原则 |<br>|     |                               |             |</p><h2 id="1-、单一职责原则"><a href="#1-、单一职责原则" class="headerlink" title="1)、单一职责原则"></a>1)、单一职责原则</h2><p>一个Class/Interface/Method只负责一项职责。</p><h2 id="2-、开闭原则"><a href="#2-、开闭原则" class="headerlink" title="2)、开闭原则"></a>2)、开闭原则</h2><p>对扩展开放，对修改关闭。核心思想是面向抽象编程。</p><h2 id="3-、里氏替换原则"><a href="#3-、里氏替换原则" class="headerlink" title="3)、里氏替换原则"></a>3)、里氏替换原则</h2><p>子类可以扩展父类的功能，但不能改变父类原有的功能。</p><h3 id="1-子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。"><a href="#1-子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。" class="headerlink" title="(1).子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。"></a>(1).子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</h3><h3 id="2-子类中可以增加自己特有的方法。"><a href="#2-子类中可以增加自己特有的方法。" class="headerlink" title="(2).子类中可以增加自己特有的方法。"></a>(2).子类中可以增加自己特有的方法。</h3><h3 id="3-当子类的方法重载父类的方法时，方法的前置条件（即方法的输入-入参）要比父类方法的输入参数更宽松。"><a href="#3-当子类的方法重载父类的方法时，方法的前置条件（即方法的输入-入参）要比父类方法的输入参数更宽松。" class="headerlink" title="(3).当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。"></a>(3).当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。</h3><h3 id="4-当子类的方法实现父类的方法时（重写-重载或实现抽象方法），方法的后置条件（即方法的输出-返回值）要比父类更严格或相等。"><a href="#4-当子类的方法实现父类的方法时（重写-重载或实现抽象方法），方法的后置条件（即方法的输出-返回值）要比父类更严格或相等。" class="headerlink" title="(4).当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。"></a>(4).当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。</h3><h2 id="4-、接口隔离原则"><a href="#4-、接口隔离原则" class="headerlink" title="4)、接口隔离原则"></a>4)、接口隔离原则</h2><p>类不应该依赖不需要的接口，知道越少越好。<br>是指用多个专门的接口，而不使 用单一的总接口。</p><h2 id="5-、依赖倒置原则"><a href="#5-、依赖倒置原则" class="headerlink" title="5)、依赖倒置原则"></a>5)、依赖倒置原则</h2><h3 id="1-高层模块不应该依赖低层模块，两者都应该依赖其抽象。"><a href="#1-高层模块不应该依赖低层模块，两者都应该依赖其抽象。" class="headerlink" title="(1).高层模块不应该依赖低层模块，两者都应该依赖其抽象。"></a>(1).高层模块不应该依赖低层模块，两者都应该依赖其抽象。</h3><h3 id="2-抽象不应该依赖细节。"><a href="#2-抽象不应该依赖细节。" class="headerlink" title="(2).抽象不应该依赖细节。"></a>(2).抽象不应该依赖细节。</h3><h3 id="3-细节应该依赖抽象。"><a href="#3-细节应该依赖抽象。" class="headerlink" title="(3).细节应该依赖抽象。"></a>(3).细节应该依赖抽象。</h3><p>比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。</p><h2 id="6-、迪米特法则"><a href="#6-、迪米特法则" class="headerlink" title="6)、迪米特法则"></a>6)、迪米特法则</h2><p>一个对象应该对其他对象保持最少的了解，又 叫最少知道原则(Least Knowledge Principle,LKP)，尽量降低类与类之间的耦合。</p><h2 id="7-、合成复用原则"><a href="#7-、合成复用原则" class="headerlink" title="7)、合成复用原则"></a>7)、合成复用原则</h2><p>尽量使用对象组合(has-a)/聚合(contanis-a)，而不是继承关系达到软件复用的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、软件设计的原则&quot;&gt;&lt;a href=&quot;#1、软件设计的原则&quot; class=&quot;headerlink&quot; title=&quot;1、软件设计的原则&quot;&gt;&lt;/a&gt;1、软件设计的原则&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lilyssh.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilyssh.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式  工厂</title>
    <link href="https://lilyssh.cn/design-pattern/3-factory/"/>
    <id>https://lilyssh.cn/design-pattern/3-factory/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2019-12-15T07:37:20.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、简单工厂"><a href="#1、简单工厂" class="headerlink" title="1、简单工厂"></a>1、简单工厂</h1><a id="more"></a><h2 id="1-、定义"><a href="#1-、定义" class="headerlink" title="1)、定义"></a>1)、定义</h2><p>简单工厂模式（Simple Factory Pattern）是指由一个工厂对象 决定创建出哪一种产品类的实例。 属于创建型模式，但它不属于GOF，23种设计模式。</p><h2 id="2-、适用场景"><a href="#2-、适用场景" class="headerlink" title="2)、适用场景"></a>2)、适用场景</h2><p>工厂类负责创建的对象较少。<br>客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。</p><h2 id="3-、优点"><a href="#3-、优点" class="headerlink" title="3)、优点"></a>3)、优点</h2><p>只需传入一个正确的参数，就可以获取你所需要的对象无须知道其创建的细节。</p><h2 id="4-、缺点"><a href="#4-、缺点" class="headerlink" title="4)、缺点"></a>4)、缺点</h2><p>工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则。 不易于扩展复杂的产品结构。</p><h2 id="4-、案例"><a href="#4-、案例" class="headerlink" title="4)、案例"></a>4)、案例</h2><p>Calandar.getInstance()<br>LoggerFactory.getLogger()<br>同时也是单例模式。</p><h1 id="2、工厂方法模式"><a href="#2、工厂方法模式" class="headerlink" title="2、工厂方法模式"></a>2、工厂方法模式</h1><h2 id="1-、优点"><a href="#1-、优点" class="headerlink" title="1)、优点"></a>1)、优点</h2><p>（1）工厂方法用来创建客户所需要的产品，同时隐藏了哪种具体产品类将被实例化的细节，用户只需要要关注工厂，不需要关注创建的细节！<br>（2）在增加修改新类时，只需要增加对应的工厂就好，完全符合开闭原则！<br>（3）创建对象的细节完全封装在具体的工厂内部，而且有了抽象的工厂类，所有的具体工厂都继承了自己的父类！完美的体现了多态性！</p><h2 id="2-、缺点"><a href="#2-、缺点" class="headerlink" title="2)、缺点"></a>2)、缺点</h2><p>（1）类的个数过多，增加了代码结构的复杂度。<br>（2）增加了理解难度。</p><h1 id="2、抽象工厂模式"><a href="#2、抽象工厂模式" class="headerlink" title="2、抽象工厂模式"></a>2、抽象工厂模式</h1><h2 id="1-、优点-1"><a href="#1-、优点-1" class="headerlink" title="1)、优点"></a>1)、优点</h2><p>具体产品在应用层代码隔离，无须关心创建细节<br>将一个系列的产品族统一到一起创建。</p><h2 id="2-、缺点-1"><a href="#2-、缺点-1" class="headerlink" title="2)、缺点"></a>2)、缺点</h2><p>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。<br>增加了理解难度。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单工厂违反了开闭原则，工厂方法与抽象工厂完美的解决了简单工厂的弊端！工厂方法的工厂个数过多，导致系统庞大，抽象工厂增加新的产品族很方便！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、简单工厂&quot;&gt;&lt;a href=&quot;#1、简单工厂&quot; class=&quot;headerlink&quot; title=&quot;1、简单工厂&quot;&gt;&lt;/a&gt;1、简单工厂&lt;/h1&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lilyssh.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilyssh.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式  单例</title>
    <link href="https://lilyssh.cn/design-pattern/4-sigleton/"/>
    <id>https://lilyssh.cn/design-pattern/4-sigleton/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2019-12-16T03:39:31.863Z</updated>
    
    <content type="html"><![CDATA[<p>1、掌握单例模式的应用场景。<br>2、掌握IDEA环境下的多线程调试方式。<br>3、掌握保证线程安全的单例模式策略。<br>4、掌握反射暴力攻击单例解决方案及原理分析。<br>5、序列化破坏单例的原理及解决方案。<br>6、掌握常见的单例模式写法。</p><a id="more"></a><h1 id="1、单例"><a href="#1、单例" class="headerlink" title="1、单例"></a>1、单例</h1><p>单例的四大原则：<br>1.构造私有。<br>2.以静态方法或者枚举返回实例。<br>3.确保实例只有一个，尤其是多线程环境。<br>4.确保反序列换时不会重新构建对象。</p><h2 id="1-、定义"><a href="#1-、定义" class="headerlink" title="1)、定义"></a>1)、定义</h2><p>单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。 隐藏其所有的构造方法。<br>属于创建型模式。</p><h2 id="2-、适用场景"><a href="#2-、适用场景" class="headerlink" title="2)、适用场景"></a>2)、适用场景</h2><p>1.资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>2.控制资源的情况下，方便资源之间的互相通信。如线程池等。 </p><h2 id="2-、常见写法"><a href="#2-、常见写法" class="headerlink" title="2)、常见写法"></a>2)、常见写法</h2><h3 id="1-、饿汉式单例"><a href="#1-、饿汉式单例" class="headerlink" title="(1)、饿汉式单例"></a>(1)、饿汉式单例</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，<font color="red">以空间换时间，故不存在线程安全问题。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先静态、后动态</span></span><br><span class="line">    <span class="comment">//先属性、后方法</span></span><br><span class="line">    <span class="comment">//先上后下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton(); <span class="comment">//有final，防止别处修改值。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-、懒汉式单例"><a href="#2-、懒汉式单例" class="headerlink" title="(2)、懒汉式单例"></a>(2)、懒汉式单例</h3><p>被外部类调用时才创建实例</p><h4 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态块，公共内存区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingleton lazy = <span class="keyword">null</span>;   <span class="comment">//没final，在全局访问点赋值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> LazySimpleSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LazySimpleSingleton singleton = LazySimpleSingleton.getInstance();</span><br><span class="line"><span class="comment">//        ThreadLocalSingleton singleton = ThreadLocalSingleton.getInstance();</span></span><br><span class="line"><span class="comment">//        LazyDoubleCheckSingleton singleton = LazyDoubleCheckSingleton.getInstance();</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + singleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">"End"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>synchronized</code>加锁，在线程数量比较多情况下，大批量线程会出现阻塞，从而导致程序运行性能大幅下降。<br>既兼顾线程安全又提升程序性能的方式：</p><h4 id="2、双重检查锁的单例模式："><a href="#2、双重检查锁的单例模式：" class="headerlink" title="2、双重检查锁的单例模式："></a>2、双重检查锁的单例模式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> LazyDoubleCheckSingleton(); <span class="comment">//1.分配内存给这个对象。2.初始化对象。3.设置lazy指向刚分配的内存地址。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。<br>不加volatile的隐患：<br>有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，访问到的是一个初始化未完成的对象。<br>为了解决上述问题，需要在lazy前加入关键字volatile。使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p><h4 id="3、内部类的单例模式："><a href="#3、内部类的单例模式：" class="headerlink" title="3、内部类的单例模式："></a>3、内部类的单例模式：</h4><p>懒加载。线程安全。<br>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LazyHolder.LAZY != <span class="keyword">null</span>)&#123;  <span class="comment">//为了防止暴力初始化，此处需要判断。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static 是为了使单例的空间共享。final保证这个方法不会被重写，重载。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在返回结果以前，一定会先加载内部类</span></span><br><span class="line">        <span class="keyword">return</span> LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认不加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = LazyInnerClassSingleton.class;</span><br><span class="line">            Constructor c = clazz.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">//通过反射拿到私有的构造方法</span></span><br><span class="line">            c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o1 = c.newInstance(); <span class="comment">//暴力初始化</span></span><br><span class="line">            Object o2 = c.newInstance(); <span class="comment">//调用了两次构造方法，相当于new了两次</span></span><br><span class="line">            System.out.println(o1 == o2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-、注册式单例"><a href="#3-、注册式单例" class="headerlink" title="(3)、注册式单例"></a>(3)、注册式单例</h3><h3 id="4-、ThreadLocal单例"><a href="#4-、ThreadLocal单例" class="headerlink" title="(4)、ThreadLocal单例"></a>(4)、ThreadLocal单例</h3><h2 id="3-、优点"><a href="#3-、优点" class="headerlink" title="3)、优点"></a>3)、优点</h2><h2 id="4-、缺点"><a href="#4-、缺点" class="headerlink" title="4)、缺点"></a>4)、缺点</h2><h2 id="4-、案例"><a href="#4-、案例" class="headerlink" title="4)、案例"></a>4)、案例</h2><p>Calandar.getInstance()<br>LoggerFactory.getLogger()<br>是简单工厂同时也是单例模式。<br>单例：<br>ServletContext、ServletConfig、ApplicationContext DBPool</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、掌握单例模式的应用场景。&lt;br&gt;2、掌握IDEA环境下的多线程调试方式。&lt;br&gt;3、掌握保证线程安全的单例模式策略。&lt;br&gt;4、掌握反射暴力攻击单例解决方案及原理分析。&lt;br&gt;5、序列化破坏单例的原理及解决方案。&lt;br&gt;6、掌握常见的单例模式写法。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://lilyssh.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilyssh.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式  原型</title>
    <link href="https://lilyssh.cn/design-pattern/5-Prototype/"/>
    <id>https://lilyssh.cn/design-pattern/5-Prototype/</id>
    <published>2019-12-11T16:00:00.000Z</published>
    <updated>2019-12-28T11:44:39.401Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="1-、定义"><a href="#1-、定义" class="headerlink" title="1)、定义"></a>1)、定义</h2><p>原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br>属于创建型模式。</p><h2 id="2-、适用场景"><a href="#2-、适用场景" class="headerlink" title="2)、适用场景"></a>2)、适用场景</h2><p>1、类初始化消耗资源较多。<br>2、new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）<br>3、构造函数比较复杂。<br>4、循环体中生产大量对象时，可读性下降。  </p><h2 id="2-、常见写法"><a href="#2-、常见写法" class="headerlink" title="2)、常见写法"></a>2)、常见写法</h2><h3 id="1-、饿汉式单例"><a href="#1-、饿汉式单例" class="headerlink" title="(1)、饿汉式单例"></a>(1)、饿汉式单例</h3><p>饿汉模式在类被初始化时就已经在内存中创建了对象，<font color="red">以空间换时间，故不存在线程安全问题。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先静态、后动态</span></span><br><span class="line">    <span class="comment">//先属性、后方法</span></span><br><span class="line">    <span class="comment">//先上后下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton(); <span class="comment">//有final，防止别处修改值。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-、懒汉式单例"><a href="#2-、懒汉式单例" class="headerlink" title="(2)、懒汉式单例"></a>(2)、懒汉式单例</h3><p>被外部类调用时才创建实例</p><h4 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySimpleSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//静态块，公共内存区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySimpleSingleton lazy = <span class="keyword">null</span>;   <span class="comment">//没final，在全局访问点赋值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySimpleSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazy = <span class="keyword">new</span> LazySimpleSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LazySimpleSingleton singleton = LazySimpleSingleton.getInstance();</span><br><span class="line"><span class="comment">//        ThreadLocalSingleton singleton = ThreadLocalSingleton.getInstance();</span></span><br><span class="line"><span class="comment">//        LazyDoubleCheckSingleton singleton = LazyDoubleCheckSingleton.getInstance();</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + singleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySimpleSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ExectorThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(<span class="string">"End"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用<code>synchronized</code>加锁，在线程数量比较多情况下，大批量线程会出现阻塞，从而导致程序运行性能大幅下降。<br>既兼顾线程安全又提升程序性能的方式：</p><h4 id="2、双重检查锁的单例模式："><a href="#2、双重检查锁的单例模式：" class="headerlink" title="2、双重检查锁的单例模式："></a>2、双重检查锁的单例模式：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lazy == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazy = <span class="keyword">new</span> LazyDoubleCheckSingleton(); <span class="comment">//1.分配内存给这个对象。2.初始化对象。3.设置lazy指向刚分配的内存地址。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。<br>不加volatile的隐患：<br>有些编译器为了性能的原因，可能会将第二步和第三步进行重排序，访问到的是一个初始化未完成的对象。<br>为了解决上述问题，需要在lazy前加入关键字volatile。使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p><h4 id="3、内部类的单例模式："><a href="#3、内部类的单例模式：" class="headerlink" title="3、内部类的单例模式："></a>3、内部类的单例模式：</h4><p>懒加载。线程安全。<br>加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(LazyHolder.LAZY != <span class="keyword">null</span>)&#123;  <span class="comment">//为了防止暴力初始化，此处需要判断。</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许创建多个实例"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//static 是为了使单例的空间共享。final保证这个方法不会被重写，重载。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//在返回结果以前，一定会先加载内部类</span></span><br><span class="line">        <span class="keyword">return</span> LazyHolder.LAZY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认不加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> LazyInnerClassSingleton LAZY = <span class="keyword">new</span> LazyInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴力初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInnerClassSingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = LazyInnerClassSingleton.class;</span><br><span class="line">            Constructor c = clazz.getDeclaredConstructor(<span class="keyword">null</span>); <span class="comment">//通过反射拿到私有的构造方法</span></span><br><span class="line">            c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o1 = c.newInstance(); <span class="comment">//暴力初始化</span></span><br><span class="line">            Object o2 = c.newInstance(); <span class="comment">//调用了两次构造方法，相当于new了两次</span></span><br><span class="line">            System.out.println(o1 == o2);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-、注册式单例"><a href="#3-、注册式单例" class="headerlink" title="(3)、注册式单例"></a>(3)、注册式单例</h3><h3 id="4-、ThreadLocal单例"><a href="#4-、ThreadLocal单例" class="headerlink" title="(4)、ThreadLocal单例"></a>(4)、ThreadLocal单例</h3><h2 id="3-、优点"><a href="#3-、优点" class="headerlink" title="3)、优点"></a>3)、优点</h2><h2 id="4-、缺点"><a href="#4-、缺点" class="headerlink" title="4)、缺点"></a>4)、缺点</h2><h2 id="4-、案例"><a href="#4-、案例" class="headerlink" title="4)、案例"></a>4)、案例</h2><p>Calandar.getInstance()<br>LoggerFactory.getLogger()<br>是简单工厂同时也是单例模式。<br>单例：<br>ServletContext、ServletConfig、ApplicationContext DBPool</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;1-、定义&quot;&gt;&lt;a href=&quot;#1-、定义&quot; class=&quot;headerlink&quot; title=&quot;1)、定义&quot;&gt;&lt;/a&gt;1)、定义&lt;/h2&gt;&lt;p&gt;原型模式（Prototype Pattern）是指原型实例指定创建对象的种类，并
      
    
    </summary>
    
      <category term="设计模式" scheme="https://lilyssh.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://lilyssh.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>jvm介绍与入门</title>
    <link href="https://lilyssh.cn/jvm/1-jvm/"/>
    <id>https://lilyssh.cn/jvm/1-jvm/</id>
    <published>2019-06-20T16:00:00.000Z</published>
    <updated>2020-03-04T12:48:54.954Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、&quot;&gt;&lt;a href=&quot;#一、&quot; class=&quot;headerlink&quot; title=&quot;一、&quot;&gt;&lt;/a&gt;一、&lt;/h1&gt;
      
    
    </summary>
    
      <category term="jvm" scheme="https://lilyssh.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://lilyssh.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引机制</title>
    <link href="https://lilyssh.cn/mysql/2-mysql-B+Tree/"/>
    <id>https://lilyssh.cn/mysql/2-mysql-B+Tree/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2020-03-04T15:38:24.354Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/mysql/2-mysql-B+Tree/">https://lilyssh.cn/mysql/2-mysql-B+Tree/</a></p><p>正确的创建合适的索引是提升数据库查询性能的基础。<br><a id="more"></a></p><h1 id="一、索引是什么？"><a href="#一、索引是什么？" class="headerlink" title="一、索引是什么？"></a>一、索引是什么？</h1><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构。</p><h1 id="二、为什么要使用索引？"><a href="#二、为什么要使用索引？" class="headerlink" title="二、为什么要使用索引？"></a>二、为什么要使用索引？</h1><ol><li>索引能极大的减少存储引擎需要扫描的数据量。</li><li>索引可以把随机IO变成顺序IO。</li><li><p>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表。</p><h1 id="三、索引谁实现的"><a href="#三、索引谁实现的" class="headerlink" title="三、索引谁实现的"></a>三、索引谁实现的</h1><p>MySQL结构体系：<br><img src="https://resource.lilyssh.cn/pic/mysql_architecture.png" alt><br>Indexes是第三方公司提供的可插拔的插件式存储引擎。</p><h1 id="三、为什么选择B-Tree？"><a href="#三、为什么选择B-Tree？" class="headerlink" title="三、为什么选择B+Tree？"></a>三、为什么选择B+Tree？</h1><p>Data Structure Visualizations：<br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><p>(1)（相对）平衡二叉树<br>它的左右两个子树的高度差的绝对值不超过1。<br><img src="https://resource.lilyssh.cn/pic/balenced_binary_search_tree.png" alt></p></li></ol><p>缺点：<br>1）太深<br>数据处的高/深度决定着他的IO操作次数， IO操作耗时大。</p><p>2）太小<br>每一个磁盘块（节点/页）保存的数据量太小了。</p><p>（2）多路平衡查找树 B-Tree<br><img src="https://resource.lilyssh.cn/pic/B-Tree.png" alt></p><p>（3）加强版多路平衡查找树 B+Tree<br><img src="https://resource.lilyssh.cn/pic/B+Tree.png" alt><br> 支节点只保存索引列关键字，不保存数据，只有叶子节点才保存数据。</p><h2 id="B-Tree与B-Tree的区别："><a href="#B-Tree与B-Tree的区别：" class="headerlink" title="B+Tree与B-Tree的区别："></a>B+Tree与B-Tree的区别：</h2><p>1、B+节点关键字搜索采用闭合区间。（MYSQL推崇使用ID作为索引，由于ID是自增的数字类型，只会增大，所以采用向右拓展的一个方式。）<br>2、B+非叶节点不保存数据相关信息， 只保存关键字和子节点的引用。<br>3、B+关键字对应的数据保存在叶子节点中。<br>4、B+叶子节点是顺序排列的， 并且相邻节点具有顺序引用的关系。</p><h2 id="为什么选择B-Tree？"><a href="#为什么选择B-Tree？" class="headerlink" title="为什么选择B+Tree？"></a>为什么选择B+Tree？</h2><p>B+树是B-树的变种（ PLUS版） 多路绝对平衡查找树， 他拥有B-树的优势。<br>B+树扫库、 表能力更强。<br>B+树的磁盘读写能力更强。<br>B+树的排序能力更强。<br>B+树的查询效率更加稳定。</p><h1 id="四、B-Tree在两大引擎中如何体现"><a href="#四、B-Tree在两大引擎中如何体现" class="headerlink" title="四、B+Tree在两大引擎中如何体现"></a>四、B+Tree在两大引擎中如何体现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;datadir&apos;;</span><br></pre></td></tr></table></figure><p>可到数据存储位置。</p><h2 id="MyIsam："><a href="#MyIsam：" class="headerlink" title="MyIsam："></a>MyIsam：</h2><p>索引和数据分别存储。表定义存在.frm文件中（每个存储引擎都会有）。表中数据存在.MYD文件中。索引存在.MYI文件中。<br><img src="https://resource.lilyssh.cn/pic/MyIsam_index.png" alt><br>多个索引：<br><img src="https://resource.lilyssh.cn/pic/MyIsam_multi-column_index.png" alt><br>每个索引都存有每条数据的地址，一旦有变，维护起来比较耗时。</p><h2 id="InnoDB："><a href="#InnoDB：" class="headerlink" title="InnoDB："></a>InnoDB：</h2><p><img src="https://resource.lilyssh.cn/pic/InnoDB_index.png" alt><br>数据就存在索引的叶子节点中。<br>辅助索引：<br><img src="https://resource.lilyssh.cn/pic/InnoDB_auxiliary_index.png" alt><br>其他索引存主键，再从主键索引中找数据。</p><h1 id="五、补充"><a href="#五、补充" class="headerlink" title="五、补充"></a>五、补充</h1><h2 id="联合索引列选择原则"><a href="#联合索引列选择原则" class="headerlink" title="联合索引列选择原则"></a>联合索引列选择原则</h2><p>1、经常用的列优先 【 最左匹配原则】<br>2、选择性（ 离散度） 高的列优先【 离散度高原则】（列的离散性越高，选择性就越好。）<br>3、宽度小的列优先【 最少空间原则】</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果查询列可通过索引节点中的关键字直接返回， 则该索引称之为覆盖索引。<br>覆盖索引可减少数据库IO， 将随机IO变为顺序IO， 可提高查询性能。</p><p>比如创建索引：create index idx_name_phoneNum on users(name,phoneNum);<br>查询语句：select name,phoneNum from user where name=?<br>可直接从索引树中返回关键字，不会再去查数据内容。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>（1）索引列的数据长度能少则少。<br>（2）索引一定不是越多越好， 越全越好， 一定是建合适的。<br>（3）匹配列前缀可用到索引 like 9999%， like %9999%、 like %9999用不到索引。<br>like 9999%得看情况，如果索引列离散性高，就能用到索引，离散性低，就用不到索引。<br>（4）Where 条件中 not in 和 &lt;&gt;操作无法使用索引。<br>（5）匹配范围值， order by 也可用到索引。<br>（6）多用指定列查询， 只返回自己想到的数据列， 少用select *。<br>（7）联合索引中如果不是按照索引最左列开始查找， 无法使用索引。在执行常量等值查询时，改变索引列的顺序并不会更改explain的执行结果，因为mysql底层优化器会进行优化，但是推荐按照索引顺序列编写sql语句。<br>（8）联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引。(索引列为name,age的话，name=’zhangsan’ and age&gt;20)<br>（9）联合索引中如果查询中有某个列的范围查询， 则其右边的所有列都无法使用索引。(索引列为age,name的话，age&gt;20 and name=’zhangsan’)</p><p>通俗理解口诀：<br>   全值匹配我最爱，最左前缀要遵守；<br>   带头大哥不能死，中间兄弟不能断；<br>   索引列上少计算，范围之后全失效；<br>   LIKE百分写最右，覆盖索引不写星；<br>   不等空值还有or，索引失效要少用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/mysql/2-mysql-B+Tree/&quot;&gt;https://lilyssh.cn/mysql/2-mysql-B+Tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正确的创建合适的索引是提升数据库查询性能的基础。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://lilyssh.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://lilyssh.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL执行计划</title>
    <link href="https://lilyssh.cn/mysql/3-mysql-explain-plan/"/>
    <id>https://lilyssh.cn/mysql/3-mysql-explain-plan/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-12T14:59:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/mysql/3-mysql-explain-plan/">https://lilyssh.cn/mysql/3-mysql-explain-plan/</a></p><p>查询执行流程分析<br>执行计划详解<br>存储引擎介绍</p><a id="more"></a><p>#一、理解mysql体系结构<br>MySQL结构体系：<br><img src="https://resource.lilyssh.cn/pic/mysql_architecture.png" alt></p><p>Client Connectors<br>接入方 支持协议很多<br>Management Serveices &amp; Utilities<br>系统管理和控制工具， mysqldump、 mysql复制集群、 分区管理等<br>Connection Pool<br>连接池： 管理缓冲用户连接、 用户名、 密码、 权限校验、 线程处理等需要缓存的需求<br>SQL Interface<br>SQL接口： 接受用户的SQL命令， 并且返回用户需要查询的结果<br>Parser<br>解析器， SQL命令传递到解析器的时候会被解析器验证和解析。 解析器是由Lex和YACC实现的<br>Optimizer<br>查询优化器， SQL语句在查询之前会使用查询优化器对查询进行优化<br>Cache和Buffer（高速缓存区）<br>查询缓存， 如果查询缓存有命中的查询结果， 查询语句就可以直接去查询缓存中取数据<br>pluggable storage Engines<br>插件式存储引擎。 存储引擎是MySql中具体的与文件打交道的子系统<br>file system<br>文件系统， 数据、 日志（redo， undo） 、 索引、 错误日志、 查询记录、 慢查询等</p><p>#二、查询执行路径<br><img src="https://resource.lilyssh.cn/pic/mysql_execute_path.png" alt></p><h2 id="1，mysql-客户端-服务端通信"><a href="#1，mysql-客户端-服务端通信" class="headerlink" title="1，mysql 客户端/服务端通信"></a>1，mysql 客户端/服务端通信</h2><p>mysql客户端与服务端的通信方式是“半双工” ；</p><p>全双工： 双向通信， 发送同时也可以接收。（打电话）<br>半双工： 双向通信， 同时只能接收或者是发送， 无法同时做操作。（对讲机）<br>单工： 只能单一方向传送。（听广播）</p><p>半双工通信 特点和限制：<br>客户端一旦开始发送消息， 另一端要接收完整个消息才能响应。<br>客户端一旦开始接收数据没法停下来发送指令。</p><p>对于一个mysql连接， 或者说一个线程， 时刻都有一个状态来标识这个连接正在做什么<br>查看命令 show full processlist / show processlist<br><a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</a> (状态全集)<br>Sleep<br>线程正在等待客户端发送数据<br>Query<br>连接线程正在执行查询<br>Locked<br>线程正在等待表锁的释放<br>Sorting result<br>线程正在对结果进行排序<br>Sending data<br>向请求端返回数据<br>可通过kill {id}的方式进行连接的杀掉</p><h2 id="2，查询缓存"><a href="#2，查询缓存" class="headerlink" title="2，查询缓存"></a>2，查询缓存</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>缓存SELECT操作的结果集和SQL语句；<br>新的SELECT语句， 先去查询缓存， 判断是否存在可用的记录集；</p><h3 id="判断标准"><a href="#判断标准" class="headerlink" title="判断标准"></a>判断标准</h3><p>与缓存的SQL语句， 是否完全一样， 区分大小写。<br>(简单认为存储了一个key-value结构， key为sql， value为sql查询结果集)</p><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;query_cache%&apos;;</span><br></pre></td></tr></table></figure><p><img src="https://resource.lilyssh.cn/pic/mysql_query_cache.png" alt><br>query_cache_type<br>值：0 -– 不启用查询缓存， 默认值；<br>值：1 -– 启用查询缓存， 只要符合查询缓存的要求， 客户端的查询语句和记录集<br>都可以缓存起来， 供其他客户端使用， 加上 SQL_NO_CACHE将不缓存<br>值：2 -– 启用查询缓存， 只要查询语句中添加了参数： SQL_CACHE， 且符合查询<br>缓存的要求， 客户端的查询语句和记录集， 则可以缓存起来， 供其他客户端使用<br>query_cache_size<br>允许设置query_cache_size的值最小为40K， 默认1M， 推荐设置 为： 64M/128M；<br>query_cache_limit<br>限制查询缓存区最大能缓存的查询记录集， 默认设置为1M<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;Qcache%&apos;;</span><br></pre></td></tr></table></figure></p><p>查看缓存情况<br><img src="https://resource.lilyssh.cn/pic/mysql_Qcache.png" alt></p><p>select sql_no_cache * from user where id = 1; 就不会使用缓存。</p><h3 id="不会缓存的情况："><a href="#不会缓存的情况：" class="headerlink" title="不会缓存的情况："></a>不会缓存的情况：</h3><p>1.当查询语句中有一些不确定的数据时， 则不会被缓存。 如包含函数NOW()，<br>CURRENT_DATE()等类似的函数， 或者用户自定义的函数， 存储函数， 用户变<br>量等都不会被缓存。<br>2.当查询的结果大于query_cache_limit设置的值时， 结果不会被缓存。<br>3.对于InnoDB引擎来说， 当一个语句在事务中修改了某个表， 那么在这个事务<br>提交之前， 所有与这个表相关的查询都无法被缓存。 因此长时间执行事务，<br>会大大降低缓存命中率。<br>4， 查询的表是系统表。<br>5， 查询语句不涉及到表。</p><h3 id="为什么mysql默认关闭了缓存开启？"><a href="#为什么mysql默认关闭了缓存开启？" class="headerlink" title="为什么mysql默认关闭了缓存开启？"></a>为什么mysql默认关闭了缓存开启？</h3><p>1.在查询之前必须先检查是否命中缓存,浪费计算资源。<br>2.如果这个查询可以被缓存， 那么执行完成后， MySQL发现查询缓存中没有这个查询， 则会将结果存入查询缓存， 这会带来额外的系统消耗。<br>3.针对表进行写入或更新数据时， 将对应表的所有缓存都设置失效。<br>4.如果查询缓存很大或者碎片很多时， 这个操作可能带来很大的系统消耗。</p><h3 id="查询缓存-适用场景"><a href="#查询缓存-适用场景" class="headerlink" title="查询缓存 适用场景"></a>查询缓存 适用场景</h3><p>以读为主的业务， 数据生成之后就不常改变的业务，比如门户类、 新闻类、 报表类、 论坛类等。</p><h2 id="3，查询优化处理"><a href="#3，查询优化处理" class="headerlink" title="3，查询优化处理"></a>3，查询优化处理</h2><h3 id="查询优化处理的三个阶段："><a href="#查询优化处理的三个阶段：" class="headerlink" title="查询优化处理的三个阶段："></a>查询优化处理的三个阶段：</h3><p>• 解析sql<br>通过lex词法分析,yacc语法分析将sql语句解析成解析树<br><a href="https://www.ibm.com/developerworks/cn/linux/sdk/lex/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/sdk/lex/</a><br>• 预处理阶段<br>根据mysql的语法的规则进一步检查解析树的合法性， 如： 检查数据的表<br>和列是否存在， 解析名字和别名的设置。 还会进行权限的验证<br>• 查询优化器<br>优化器的主要作用就是找到最优的执行计划</p><h2 id="4，查询执行引擎"><a href="#4，查询执行引擎" class="headerlink" title="4，查询执行引擎"></a>4，查询执行引擎</h2><h2 id="5，返回客户端"><a href="#5，返回客户端" class="headerlink" title="5，返回客户端"></a>5，返回客户端</h2><p>#三、各大存储引擎介绍</p><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>数据存储以CSV文件</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>不能定义没有索引、 列定义必须为NOT NULL、 不能设置自增列<br>–&gt;不适用大表或者数据的在线处理<br>CSV数据的存储用,隔开， 可直接编辑CSV文件进行数据的编排<br>–&gt;数据安全性低<br>注： 编辑之后， 要生效使用flush table XXX 命令</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>数据的快速导出导入。<br>表格直接转换成CSV。</p><h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>压缩协议进行数据的存储。数据存储为ARZ文件格式。</p><h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><p>只支持insert和select两种操作。<br>只允许自增ID列建立索引。<br>行级锁。<br>不支持事务。<br>数据占用磁盘少。</p><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><p>日志系统。<br>大量的设备数据采集。</p><h2 id="Memory-heap"><a href="#Memory-heap" class="headerlink" title="Memory/heap"></a>Memory/heap</h2><p>数据都是存储在内存中， IO效率要比其他引擎高很多。服务重启数据丢失。内存数据表默认只有16M。</p><h3 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h3><p>支持hash索引，B tree索引，默认hash（查找复杂度0(1)）。<br>字段长度都是固定长度varchar(32)=char(32)。<br>不支持大数据存储类型字段如 blog，text。<br>表级锁</p><h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><p>等值查找热度较高数据。<br>查询结果内存中的计算， 大多数都是采用这种存储引擎。<br>作为临时表存储需计算的数据。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>Mysql5.5版本之前的默认存储引擎<br>较多的系统表也还是使用这个存储引擎<br>系统临时表也会用到Myisam存储引擎</p><h3 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h3><p>a，select count(*) from table 无需进行数据的扫描<br>b，数据（MYD） 和索引（MYI） 分开存储<br>c，表级锁<br>d，不支持事务</p><h2 id="InnoDB："><a href="#InnoDB：" class="headerlink" title="InnoDB："></a>InnoDB：</h2><p>Mysql5.5及以后版本的默认存储引擎</p><h3 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h3><p>支持事务<br>支持行级锁<br>聚集索引（主键索引） 方式进行数据存储<br>支持外键关系保证数据完整性</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/mysql/3-mysql-explain-plan/&quot;&gt;https://lilyssh.cn/mysql/3-mysql-explain-plan/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查询执行流程分析&lt;br&gt;执行计划详解&lt;br&gt;存储引擎介绍&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://lilyssh.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://lilyssh.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>kafka原理</title>
    <link href="https://lilyssh.cn/architecture/13-kafka/"/>
    <id>https://lilyssh.cn/architecture/13-kafka/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.395Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Kafka</a> 2.0.0。<br><a id="more"></a></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>分布式的消息和订阅系统，高性能、高吞吐量。<br>内置分区（对数据做分片处理）、实现集群、有容错能力和数据复制能力。</p><h1 id="二、产生背景"><a href="#二、产生背景" class="headerlink" title="二、产生背景"></a>二、产生背景</h1><p>领英要对用户的行为进行统计。</p><h1 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h1><p>行为跟踪：收集用户的操作行为。可以根据爱好做推送。<br>日志收集。</p><h1 id="四、术语"><a href="#四、术语" class="headerlink" title="四、术语"></a>四、术语</h1><ul><li>Topic<br>存储消息的逻辑概念。</li><li>Partition</li></ul><ol><li>每个topic可以划分多个分区。</li><li>相同topic下的不同分区的消息是不同的。如果是集群，分区会均分在集群机子上。<br><img src="https://resource.lilyssh.cn/pic/kafka-partition.png" alt><br>设置分区目的：减少消息容量，从而提升io性能。</li></ol><h1 id="五、架构"><a href="#五、架构" class="headerlink" title="五、架构"></a>五、架构</h1><p><img src="https://resource.lilyssh.cn/pic/kafka-architecture.png" alt><br>一个kafka集群会包含多个broker，它又依赖zookeeper的集群，去实现broker之间的master-slaver机制。<br>多个producer，多个consumer。<br>消费者去broker里pull消息的。而mq是主动推送给消费者。</p><h1 id="六、消息的同步发送和异步发送"><a href="#六、消息的同步发送和异步发送" class="headerlink" title="六、消息的同步发送和异步发送"></a>六、消息的同步发送和异步发送</h1><ul><li>异步发送：<br>kafka1.0以后，默认的client使用的都是异步发送消息。消息通过kafka producer发送后，这个消息放到了后台一个消息队列里，然后通过一个线程不断的从队列里取出消息进行发送。消息发送成功后，会进行一个callback回调。</li><li>同步发送：<br>通过future和get。get方法是个阻塞。同步去获得结果。</li></ul><h1 id="七、消息分发策略"><a href="#七、消息分发策略" class="headerlink" title="七、消息分发策略"></a>七、消息分发策略</h1><p>消息由key和value组成，key是可选项，producer会根据key和partition机制来判断当前这条消息应该放到哪个partition里面。默认算法是哈希取模。如果key为null，则随机分配，根据metadata.max.age.ms来，十分钟更新一次。<br>分区分配策略：</p><ul><li>Range（范围） -&gt; 默认<br>针对于同一个topic中的多个partition而言的。首先会对这个topic中的partition进行排序，然后 partition数量除以consumer数量，加入有0-9个partition，3个consumer，那consumer1会消费前4个分区。如果是多个topic，那每次多消费的都是第一个。</li><li>轮询Round-Robin<br>把所有的partition和consumer数量列出来，然后按照hashcode进行排序，通过轮询算法分配partition和consumer。</li></ul><p>也可以自定义分发规则，implements Partitioner。</p><p>什么时候会触发rebalance ？<br>1、对于同一个consumer group，新增consumer<br>2、consumer离开<br>3、consumer取消订阅<br>4、topic中新增分区</p><p>谁来执行rebalance，以及管理consumer group？<br>coordinator</p><h1 id="八、消息的存储策略"><a href="#八、消息的存储策略" class="headerlink" title="八、消息的存储策略"></a>八、消息的存储策略</h1><ul><li>消息保存的路径<br>默认tmp，也可以自定义。</li><li>消息的写入性能<br>顺序写入<br>零拷贝</li><li>消息的存储机制<br>日志分段，方便清理和压缩。根据时间（默认保留7天）或者 大小，满足其中之一，就会被清理掉。<br><img src="https://resource.lilyssh.cn/pic/kafka-segment.png" alt><br><img src="https://resource.lilyssh.cn/pic/kafka-consume-msg.png" alt></li></ul><h1 id="九、Partition副本机制"><a href="#九、Partition副本机制" class="headerlink" title="九、Partition副本机制"></a>九、Partition副本机制</h1><p>分区是对数据内容的分片，每个分区里的内容不一样，当一个分区不可用时，有一部分消息就没办法消费。所以为了提高分区的可用性，去实现冗余的备份，就是副本。如果有多个副本，一定会有个leader副本和follower副本。命令中通过<code>--replication-factor</code>参数去设置。<br>第i个分区的第j个副本，会落在 第 (i+j)% broker counts 个broker上。<br>查看分区状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /brokers/topics/topic_name/partitions/partition_num/state</span><br></pre></td></tr></table></figure></p><p>其中 isr维护的是当前分区，所有的副本集。follower的内容必须跟leader的在一定阈值范围内保持一致，如果不一致，就会被踢出去，直到follower的内容与leader内容保持在一定阈值范围内，follower才会被加进来。<br>leader副本 负责接收客户端的写入和读取请求。<br>follower副本 负责从leader副本中读取数据。</p><h1 id="十、消息消费原理"><a href="#十、消息消费原理" class="headerlink" title="十、消息消费原理"></a>十、消息消费原理</h1><p>consumer可以指定消费哪个partition。如果不指定，会按照一定的策略进行负载，比如三个consumer、三个partition，就一个consumer消费一个partition。如果consumer数量小于partition数量，则有的consumer会多消费一些partition。如果consumer数量大于partition数量，则有的consumer会消费不到消息，会造成一定的浪费，所以不建议设置太多的consumer。因为在一个partition上是不允许并发的。consumer的数量最好是partition数量的整数倍。如果consumer从多个partition上读到消息，是不保证顺序的。<br><img src="https://resource.lilyssh.cn/pic/kafka-broker.png" alt></p><h1 id="十、集群"><a href="#十、集群" class="headerlink" title="十、集群"></a>十、集群</h1><p>集群的构建是基于zookeeper的。<br>修改config/server.properties中三个地方：</p><ol><li>zookeeper的地址，</li><li>broker.id（在kafka集群中必须是唯一的）。</li><li>listeners，是为了各个节点互相通信，所以需要写各个节点自己的ip。</li></ol><p>启动集群各节点kafka后，会看到zookeeper上多了几个节点。<br>启动zookeeper客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zookeeper-3.5.4-beta/bin/zkCli.sh</span><br></pre></td></tr></table></figure></p><p>查看所有kafka集群节点的id：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /brokers/ids</span><br></pre></td></tr></table></figure></p><p>查看kafka主节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /controller</span><br></pre></td></tr></table></figure></p><p>写请求会进入master节点，读请求进入其他节点。<br>选举规则：最小的节点，也就是最早注册的节点是leader。</p><h1 id="十二、使用api"><a href="#十二、使用api" class="headerlink" title="十二、使用api"></a>十二、使用api</h1><ol><li><p>引入kafka依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>消息发送端<br>(1) 设置kafka配置信息(集群地址、序列化)，创建KafkaProducer。<br>可设置参数如：</p></li></ol><ul><li><p>ProducerConfig.ACKS_CONFIG，<br>0：消息发送给broker以后，不需要确认（性能较高，但是数据会丢失）。<br>1：只需要获得kafka集群中leader节点的确认，即可返回。<br>all(-1)：需要集群中的所有节点确认。（最安全，性能最低的）</p></li><li><p>batch.size(默认16kb)<br>producer对于同一个分区来说，会按照batch.size的大小进行统一收集后，批量发送。</p></li><li><p>linger.ms<br>按时间间隔，进行统一收集后，批量发送。<br>如果都设置了，满足其中任意一个条件，消息就会立马发送。<br>为了解决大量的小数据包频繁的发送，这个问题。</p></li><li><p>max.request.size(默认1M)<br>控制请求的大小</p></li></ul><p>(2) 通过send方法发送消息，入参为ProducerRecord(topic,message)。</p><ol start="3"><li>消息接受端<br>(1) 设置kafka配置信息(集群地址、序列化)，创建KafkaConsumer。<br>不同的组，只要订阅了，每个组都可以获取消息。<br>同一个组内的消费者们，只能有一个消费者能获取到消息，其他成员不会获取到。<br>可设置参数如：</li></ol><ul><li>AUTO_OFFSET_RESET_CONFIG：<br>earliest：对于新的group id来说，它会从最早的消息开始消费。对于已经消费过消息的group id来说，它还是会从已经消费过的最大的offset里去取。<br>latest：对于新的group_id来说，直接从已经消费过并且提交的最大的偏移量开始取。<br><img src="https://resource.lilyssh.cn/pic/kafka-group.png" alt><ul><li>ENABLE_AUTO_COMMIT_CONFIG:自动提交</li><li>AUTO_COMMIT_INTERVAL_MS_CONFIG：自动提交的间隔毫秒<br>就是说每xx毫秒，对这个时间段内的所有消息，进行提交确认。<br>消息消费完以后，要进行提交确认。如果设置为false的话，消费一次后，还允许再次消费。设置为true，则消费一次后，不会被再次消费到。</li><li>MAX_POLL_RECORDS_CONFIG：每一次调用poll，获取到的消息数。这样可以根据消费端的处理性能，来预设一个数量，减少poll的次数，提升性能。</li></ul></li></ul><p>(2) 通过subscribe方法订阅消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kafka&lt;/a&gt; 2.0.0。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="https://lilyssh.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="高并发架构实战" scheme="https://lilyssh.cn/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98/"/>
    
      <category term="测试" scheme="https://lilyssh.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Kafka" scheme="https://lilyssh.cn/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Cypherium Java smart contract programming guide</title>
    <link href="https://lilyssh.cn/blockchain/cypherium-java-smart-contract-programming-guide/"/>
    <id>https://lilyssh.cn/blockchain/cypherium-java-smart-contract-programming-guide/</id>
    <published>2018-09-24T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.404Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://blog.csdn.net/lilyssh/article/details/82911309" target="_blank" rel="noopener">https://blog.csdn.net/lilyssh/article/details/82911309</a>  </p><p>代币就是数字货币，比特币、以太币就是一个代币。利用Cypherium的java智能合约可以轻松编写出属于自己的代币。这些代币是建立在区块链之上，代表你拥有并可转让给其他人的数字资产。现在我们就来看看怎样创建一个这样的代币。</p><h1 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h1><ol><li>下载示例代码。<a href="https://github.com/cypherium/ContractExample" target="_blank" rel="noopener">https://github.com/cypherium/ContractExample</a><br>目录结构介绍：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── client              //客户端</span><br><span class="line">│   ├── cypher          //可执行文件cypher</span><br><span class="line">│   ├── jdk             //Java Development Kit</span><br><span class="line">│   ├── genesis.json    //初始化创世区块所需文件</span><br><span class="line">│   ├── db              //自定义数据库目录</span><br><span class="line">│   └── executable_file //可执行文件</span><br><span class="line">│       ├── Linux       //Linux版本</span><br><span class="line">│       │    └── cypher</span><br><span class="line">│       ├── Mac         //Mac版本</span><br><span class="line">│       │    └── cypher</span><br><span class="line">│       └── Windows     //Windows版本</span><br><span class="line">│            └── cypher</span><br><span class="line">├── file2str            //class文件生成二进制字符串工具</span><br><span class="line">│   ├── file2str.go     //go源码</span><br><span class="line">│   ├── Linux           //Linux版本</span><br><span class="line">│   │   └── file2str</span><br><span class="line">│   ├── Mac             //Mac版本</span><br><span class="line">│   │   └── file2str</span><br><span class="line">│   └── Windows         //Windows版本</span><br><span class="line">│       └── file2str.exe</span><br><span class="line">└── src</span><br><span class="line">    ├── HelloWorld.java //Java智能合约</span><br><span class="line">    ├── index.html      //合约部署页面</span><br><span class="line">    └── web3.js</span><br></pre></td></tr></table></figure></li></ol><p>接下来的操作步骤，默认在<code>ContractExample/client</code>目录执行。<br>请根据操作系统，把合适的可执行文件cypher，复制到client下，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp executable_file/Mac/cypher ./</span><br></pre></td></tr></table></figure></p><ol start="2"><li>初始化节点的创世区块。datadir为自行指定的数据库目录，如db。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cypher --datadir db init genesis.json</span><br></pre></td></tr></table></figure><ol start="3"><li>启动节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --datadir db --networkid 123666 --port 7000 --rpcport 8000  --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0</span><br></pre></td></tr></table></figure><ol start="4"><li>启动节点的js交互窗口(用上一步成的ipc文件)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cypher attach db/cypher.ipc</span><br></pre></td></tr></table></figure><ol start="5"><li>创建账户。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.newAccount(&quot;your password&quot;)</span><br></pre></td></tr></table></figure><ol start="6"><li>请联系我们，给您的测试账户中，转入一些可供测试的代币。邮箱地址：xxx</li><li>查看您的账户余额。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cph.getBalance(&quot;your account address&quot;)</span><br></pre></td></tr></table></figure><ol start="8"><li>您可以通过以下方法，把您账户中的资金转给其他账户。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cph.sendTransaction(from,to,value,gas,gasPrice,data,nonce,Function)</span><br></pre></td></tr></table></figure><ul><li>from: String - 指定的发送者的地址。  </li><li>to: String - （可选）交易消息的目标地址，如果是合约创建，则不填。  </li><li>value: Number|String|BigNumber - （可选）交易携带的货币量，以wei为单位。如果合约创建交易，则为初始的基金。  </li><li>gas: Number|String|BigNumber - （可选）默认是自动，交易可使用的gas，未使用的gas会退回。  </li><li>gasPrice: Number|String|BigNumber - （可选）默认是自动确定，交易的gas价格，默认是网络gas价格的平均值 。  </li><li>data: String - （可选）或者包含相关数据的字节字符串，如果是合约创建，则是初始化要用到的代码。 </li><li>nonce: Number - （可选）整数，使用此值，可以允许你覆盖你自己的相同nonce的，正在pending中的交易。</li><li>Function - 回调函数，用于支持异步的方式执行。  </li></ul><ol start="9"><li>通过以下命令查看现在共识到第几个区块了。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cph.txBlockNumber</span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>ERC20是以太坊定义的一个代币标准。要求我们在实现代币的时候必须要遵守的协议，如指定代币名称、总量、实现代币交易函数等，只有支持了协议才能被以太坊钱包支持。<br>Cypherium的代币标准接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.cypher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cypnet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置代币信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol 代币符号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 代币名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalSupply 发行代币总量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _owner 合约拥有者账户地址，传""空时，代表默认为创建者账户地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">setTokenInfo</span><span class="params">(String symbol, String name, <span class="keyword">long</span> totalSupply, String _owner)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取合约创建者的账户地址。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addressType can be "caller","self","owner" and other filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getAddress</span><span class="params">(String addressType)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看对应账号的代币余额。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _address</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">balanceOf</span><span class="params">(String _address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改指定账户余额。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">changeBalance</span><span class="params">(String _from, <span class="keyword">long</span> _value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现代币交易</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transfer</span><span class="params">(String _from, String _to, <span class="keyword">long</span> _value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置键值对。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">setState</span><span class="params">(String _key, String _value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过键获取值。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> _key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getState</span><span class="params">(String _key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Create-contract"><a href="#Create-contract" class="headerlink" title="Create contract"></a>Create contract</h1><p>现在我们来开始编写第一个<a href="https://github.com/cypherium/ContractExample/blob/master/src/HelloWorld.java" target="_blank" rel="noopener">Java智能合约</a>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.cypher.Cypnet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> totalSupply = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//我们创建一个 符号为Hello,名称为Hello world,发行总量为10000的代币。</span></span><br><span class="line">        Cypnet.setTokenInfo(<span class="string">"Hello"</span>, <span class="string">"Hello world"</span>, totalSupply, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">//把发行的代币全都给合约创建者</span></span><br><span class="line">        Cypnet.changeBalance(<span class="string">"caller"</span>, totalSupply);</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transfer</span><span class="params">(String _to, <span class="keyword">long</span> _value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = Cypnet.balanceOf(<span class="string">"caller"</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; _value) &#123;</span><br><span class="line">            <span class="comment">//throw new Exception("Insufficient balance");</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Insufficient balance"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Cypnet.transfer(<span class="string">"caller"</span>, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getValue</span><span class="params">(String skey)</span> </span>&#123;</span><br><span class="line">        String s = Cypnet.getState(skey);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setValue</span><span class="params">(String skey, String sValue)</span> </span>&#123;</span><br><span class="line">        Cypnet.setState(skey, sValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单解释下，我们定义了一个名为HelloWorld的合约，main方法是Java应用程序的入口方法，导入Cypnet类。  </p><h1 id="Compile-contract"><a href="#Compile-contract" class="headerlink" title="Compile contract"></a>Compile contract</h1><ol><li>我们来把HelloWorld.java编译成字节码文件HelloWorld.class。编译命令如下： </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -cp jdk/classes ../src/HelloWorld.java</span><br></pre></td></tr></table></figure><ol start="2"><li>给<a href="https://github.com/cypherium/ContractExample/tree/master/file2str" target="_blank" rel="noopener">file2str</a>赋上权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ../file2str</span><br></pre></td></tr></table></figure><p>3.根据操作系统，选择合适的<code>file2str</code>，将 HelloWorld.class文件转成16进制字符串的命令 file2str HelloWorld.class，如Mac版为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../file2str/Mac/file2str ../src/HelloWorld.class</span><br></pre></td></tr></table></figure><p>会看到生成的二进制字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xcafebabe00000036005a0a001a002d05000000000000271008002e08002f0800300a003100320800330a003100340800350800360a00310037090038003908003a0a003b003c0a0031003d0a0031003e08003f0a003100400800410800420a003b00430800440800450700460700470100063c696e69743e010003282956010004436f646501000f4c696e654e756d6265725461626c650100046d61696e010016285b4c6a6176612f6c616e672f537472696e673b29560100087472616e73666572010027284c6a6176612f6c616e672f537472696e673b4a294c6a6176612f6c616e672f537472696e673b01000d537461636b4d61705461626c6501000867657456616c7565010026284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f537472696e673b01000873657456616c7565010038284c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f537472696e673b01000967657456616c75653101001428294c6a6176612f6c616e672f537472696e673b01000967657456616c75653201000a536f7572636546696c6501000f48656c6c6f576f726c642e6a6176610c001b001c01000548656c6c6f01000b48656c6c6f20776f726c640100000700480c0049004a01000663616c6c65720c004b004c0100047465737401001048656c6c6f20776f726c6420746573740c004d004e07004f0c0050005101001448656c6c6f20776f726c6420436f6e74726163740700520c005300540c005500250c00560057010014496e73756666696369656e742062616c616e63650c00210058010004414141410100026f6b0c0053005901000973647364736473646401000331303001000a48656c6c6f576f726c640100106a6176612f6c616e672f4f626a6563740100136a617661782f6379706865722f4379706e657401000c736574546f6b656e496e666f01003a284c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f537472696e673b4a4c6a6176612f6c616e672f537472696e673b295a01000d6368616e676542616c616e6365010016284c6a6176612f6c616e672f537472696e673b4a295a0100087365745374617465010027284c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f537472696e673b295a0100106a6176612f6c616e672f53797374656d0100036f75740100154c6a6176612f696f2f5072696e7453747265616d3b0100136a6176612f696f2f5072696e7453747265616d0100077072696e746c6e010015284c6a6176612f6c616e672f537472696e673b2956010008676574537461746501000962616c616e63654f66010015284c6a6176612f6c616e672f537472696e673b294a010028284c6a6176612f6c616e672f537472696e673b4c6a6176612f6c616e672f537472696e673b4a295a0100042849295600210019001a0000000000070001001b001c0001001d0000001d00010001000000052ab70001b100000001001e000000060001000000030009001f00200001001d00000068000500040000003414000240120412051f1206b800075712081fb8000957120a120bb8000c57b2000d120eb6000f120ab800104eb2000d2db6000fb100000001001e0000002200080000000500040008000f00090016000b001e000c0026000e002c000f003300100009002100220001001d0000007a00040006000000351208b80011370416041f949c00061212b012082a1fb8001357120ab800104eb2000d2db6000f1214b800104eb2000d2db6000f01b000000002001e0000002600090000001400070015000e0017001100190019001b001f001c0026001e002c001f003300210023000000070001fd001100040009002400250001001d0000002300010002000000072ab800104c2bb000000001001e0000000a000200000025000500260009002600270001001d0000002500020002000000092a2bb8000c571215b000000001001e0000000a0002000000290006002a0009002800290001001d0000004e0002000100000019033b1a112710a20010b2000d1ab60016840001a7ffef1217b000000002001e0000001600050000003e000200400009004100100042001600440023000000070002fc000201130009002a00290001001d0000001b00010000000000031218b000000001001e000000060001000000470001002b00000002002c</span><br></pre></td></tr></table></figure></p><ol start="4"><li>部署合约<br>我们需要用<code>Chrome</code>浏览器打开部署调用页面ContractExample/src/index.html<br>如下：<br><img src="https://resource.lilyssh.cn/pic/java_contract_init.png" alt></li></ol><p>如果使用的是其他浏览器，直接打开会有跨域请求问题，所以需要使用http-server来部署该页面,需要自行先安装node和npm，再安装http-server，请依次执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install http-server -g </span><br><span class="line"></span><br><span class="line">pm i http-server</span><br><span class="line"></span><br><span class="line">yarn -g http-server</span><br></pre></td></tr></table></figure></p><p>进入到CypherTestNet/web3-cypher.js目录下，执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server</span><br></pre></td></tr></table></figure></p><p>用浏览器访问<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>  把刚生成的二进制字符串粘到Java contract bytecode文本框。<br>在From Account账户有余额的情况下，点击Deploy按钮后，会把您的java合约部署到区块链中。并会弹出合约地址信息。<br><!-- <img src="https://resource.lilyssh.cn/pic/deploy_submitted.png" width="896" height="252" /> --><br><img src="https://resource.lilyssh.cn/pic/deploy_submitted.png" alt><br><img src="https://resource.lilyssh.cn/pic/contract_address.png" alt><br>点击Get contract info按钮获取区块链中的合约信息。<br><img src="https://resource.lilyssh.cn/pic/contract_info.png" alt><br>在文本框中输入转账金额，并点击Transfer按钮，付款方就会向收款方转账。<br><img src="https://resource.lilyssh.cn/pic/transfer.png" alt><br>点击From’s Balance按钮查看付款账户的余额。<br><img src="https://resource.lilyssh.cn/pic/from_balance.png" alt><br>点击To’s Balance按钮查看收款账户的余额。<br><img src="https://resource.lilyssh.cn/pic/to_balance.png" alt></p><h1 id="View-deploy-contract-page"><a href="#View-deploy-contract-page" class="headerlink" title="View deploy contract page"></a>View deploy contract page</h1><p>接下来，我们来看看部署调用页面的流程。  </p><ol><li>web3如何调用java方法<br>ABI全称Application Binary Interface, 是调用智能合约函数以及合约之间函数调用的消息编码格式定义,也可以理解为智能合约函数调用的接口说明. 类似Webservice里的SOAP协议一样；也就是定义操作函数签名，参数编码，返回结果编码等。使用ABI协议时必须要求在编译时知道类型,即强类型相关.</li></ol><p>如果想调用HelloWorld.java中的函数，需要把该函数追加到abi变量中，按照现有格式即可。比如说，我们想要调用HelloWorld.java中的getValue方法，就要把以下内容追加到abi变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var abi=</span><br><span class="line">...</span><br><span class="line">,</span><br><span class="line">&#123;</span><br><span class="line">        &quot;constant&quot;:false,        //方法修饰符,false表示函数内可以修改状态变量</span><br><span class="line">        &quot;inputs&quot;:[               //方法入参，数组里的每个对象都是一个参数说明</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;:&quot;skey&quot;,   //第一个参数的名字</span><br><span class="line">                &quot;type&quot;:&quot;bytes32&quot; //第一个参数的类型</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;outputs&quot;:[              //方法返回值，数组里的每个对象都是一个参数说明</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;name&quot;:&quot;value&quot;,  //第一个参数的名字</span><br><span class="line">                &quot;type&quot;:&quot;bytes32&quot; //第一个参数的类型</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;name&quot;:&quot;getValue&quot;,       //方法名</span><br><span class="line">        &quot;payable&quot;:false,</span><br><span class="line">        &quot;stateMutability&quot;:&quot;nonpayable&quot;,</span><br><span class="line">        &quot;type&quot;:&quot;function&quot;        //方法类型：function,constructor,fallback,event</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>uint<m>:M为integer类型代表M bits,0 &lt; M &lt;= 256, M % 8 == 0，如uint32，uint8,uint256。<br>int<m>:同上。同为从8到256位的无符号整数。<br>uint和int:整型，分别是uint256和int256的别名。这也是上面的例子中函数参数类型是uint，转sha3码时要变成uint256的原因。<br>address:地址，20个字节，160bits，一个Ethereum地址，地址的类型也可以有成员作为所有合约的base。<br>bool:布尔类型，1个字节，true：1，false:0。<br>bytes<m>:固定大小的字节数组，0&lt;M&lt;=32,byte都是bytes1的别名。<br>bytes:动态分配大小字节数组。不是一个值类型。<br>String:动态大小UTF8编码的字符串,不是一个值类型。<br>尽量少用string。  </m></m></m></p><ol start="2"><li>如何发布合约<br>web3.js对合约的操作进行了封装。发布合约时，可以使用web3.cph.contract的new方法。<br>部署过程中需要主要的是，new方法的回调会执行两次，第一次是合约的交易创建完成，第二次是在某个地址上完成部署。需要注意的是只有在部署完成后，才能进行方法该用，否则会报错TypeError: javaContract.add is not a function。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://blog.csdn.net/lilyssh/article/details/82911309&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lilyssh/a
      
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="Cypherium" scheme="https://lilyssh.cn/tags/Cypherium/"/>
    
  </entry>
  
  <entry>
    <title>Cypherium&#39;s synchronous block test operation steps</title>
    <link href="https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/"/>
    <id>https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/</id>
    <published>2018-08-14T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.404Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/">https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Cypherium’s synchronous block test operation steps.<br><a id="more"></a></p><ol><li><p>put cypherium_internal.pem in a directory,for example,~.</p></li><li><p><code>vim ~/.ssh/config</code> file.Add alias for the ssh remote connection.</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">    ServerAliveInterval 60</span><br><span class="line">Host 119</span><br><span class="line">    HostName 18.221.58.119</span><br><span class="line">    User ubuntu</span><br><span class="line">    IdentityFile    ~/cypherium_internal.pem</span><br><span class="line">Host 200</span><br><span class="line">    HostName 18.216.16.200</span><br><span class="line">    User ubuntu</span><br><span class="line">    IdentityFile    ~/cypherium_internal.pem</span><br></pre></td></tr></table></figure><ol start="3"><li><code>ssh 119</code>,connection AWS node 18.221.58.119.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ip-172-31-31-48:~$</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── genesis.json</span><br><span class="line">├── group.toml</span><br><span class="line">├── Cypherium</span><br><span class="line">│   ├── private.toml</span><br><span class="line">│   └── public.toml</span><br><span class="line">└── cypher_db</span><br><span class="line">    ├── cypher.ipc</span><br></pre></td></tr></table></figure><ol start="4"><li>clean  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><ol start="5"><li>Compile  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make cypher</span><br></pre></td></tr></table></figure><ol start="4"><li>Generate node information </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher setup</span><br></pre></td></tr></table></figure><p>You need to enter the ip: port,Use kyber’s Ed25519 algorithm to generate <code>public.toml</code> and <code>private.toml</code>.Save in the default path. Currently there is no ip discovery, so you need to manually splicing the public key <code>~/Library/Application\ Support/cypher/public.toml</code> (Mac default path) for simulation testing. The node name can be customized, such as node_01_name.<br><img src="https://resource.lilyssh.cn/pic/cypher%20setup_.png" alt></p><ol start="5"><li><p>同理，再生成第二个节点。</p></li><li><p>把第一、二个节点的public.toml，拼接到~/workspace/test/group.toml中。</p></li></ol><p><img src="https://resource.lilyssh.cn/pic/group.toml.png" alt></p><ol start="7"><li>初始化 两个节点的创世区块。  </li></ol><p>第一个节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --datadir &quot;~/workspace/test/node_01/data&quot; init ~/workspace/test/genesis.json</span><br></pre></td></tr></table></figure></p><p>第二个节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --datadir &quot;~/workspace/test/node_02/data&quot; init ~/workspace/test/genesis.json</span><br></pre></td></tr></table></figure></p><p>genesis.json中内容可参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">        &quot;chainId&quot;: 123666,</span><br><span class="line">        &quot;homesteadBlock&quot;: 0,</span><br><span class="line">        &quot;eip155Block&quot;: 0,</span><br><span class="line">        &quot;eip158Block&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">  &quot;alloc&quot;      : &#123;&#125;,</span><br><span class="line">  &quot;coinbase&quot;   : &quot;0x0000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;difficulty&quot; : &quot;0x20000&quot;,</span><br><span class="line">  &quot;extraData&quot;  : &quot;&quot;,</span><br><span class="line">  &quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,</span><br><span class="line">  &quot;nonce&quot;      : &quot;0x0000000000000042&quot;,</span><br><span class="line">  &quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;timestamp&quot;  : &quot;0x00&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="8"><li>启动第一个节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --onetdir ~/workspace/test/node_01/private.toml --datadir ~/workspace/test/node_01/data --publickeydir ~/workspace/test/group.toml --networkid 123666 --port 7010 --rpcport 8510 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcapi eth,web3,personal --verbosity 5 2&gt; ~/workspace/test/node_01/output2.log</span><br></pre></td></tr></table></figure><ol start="9"><li>启动第一个节点的js交互窗口(用上一步成的ipc文件)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher attach ~/workspace/test/node_01/data/cypher.ipc</span><br></pre></td></tr></table></figure><ol start="10"><li>启动第二个节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --onetdir ~/workspace/test/node_02/private.toml --datadir ~/workspace/test/node_02/data --publickeydir ~/workspace/test/group.toml --networkid 123666 --port 7020 --rpcport 8520 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcapi eth,web3,personal --verbosity 5 2&gt; ~/workspace/test/node_02/output2.log</span><br></pre></td></tr></table></figure><ol start="11"><li>启动第二个节点的js交互窗口(用上一步成的ipc文件)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher attach ~/workspace/test/node_02/data/cypher.ipc</span><br></pre></td></tr></table></figure><p><img src="https://resource.lilyssh.cn/pic/attach%20node_.jpg" alt></p><ol start="12"><li>从此步骤开始，都将在js交互涌窗口执行。查看第一个节点的信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.nodeInfo</span><br></pre></td></tr></table></figure><ol start="13"><li>在第二个节点中，创建用户，保存挖矿奖励。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.newAccount(&quot;password&quot;)</span><br></pre></td></tr></table></figure><ol start="14"><li>在第二个节点中，加入第一个节点。就是把cnode中的内容粘进addPeer中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.addPeer(&quot;cnode&quot;)</span><br></pre></td></tr></table></figure><ol start="15"><li>在第一个节点中，验证一下是否已加入。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><ol start="16"><li>主节点调用开始同步命令，从交易池里取tx执行，并打包生成txBlock，发给其他委员会成员做bftcosi共识。会看到两个节点的信息都在滚动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftcosi.start()</span><br></pre></td></tr></table></figure><ol start="17"><li>停止共识。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftcosi.stop()</span><br></pre></td></tr></table></figure><ol start="18"><li>查看下两个节点的区块数量是否相同。</li></ol><p><img src="https://resource.lilyssh.cn/pic/txBlockNumber.png" alt></p><ol start="19"><li>(不时需要)解锁账户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.unlockAccount(&quot;需解锁账户&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://resource.lilyssh.cn/pic/unlockAccount.png" alt></p><ol start="20"><li>查看交易池状态，pending为待确认的交易数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txpool.status</span><br></pre></td></tr></table></figure></li></ol><p>会显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  pending: 0,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="19"><li>退出：</li></ol><p><img src="https://resource.lilyssh.cn/pic/killall.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/&quot;&gt;https://lilyssh.cn/blockchain/cypherium-test-sync-block-en/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Cypherium’s synchronous block test operation steps.&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="Cypherium" scheme="https://lilyssh.cn/tags/Cypherium/"/>
    
  </entry>
  
  <entry>
    <title>以太坊 目录结构说明</title>
    <link href="https://lilyssh.cn/blockchain/cypherium-dir-description/"/>
    <id>https://lilyssh.cn/blockchain/cypherium-dir-description/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.403Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/blockchain/cypherium-dir-description/">https://lilyssh.cn/blockchain/cypherium-dir-description/</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>go-cypherium<br>本篇为转发，只做了下样式整理，<a href="https://blog.csdn.net/jiang_xinxing/article/details/80249981" target="_blank" rel="noopener">原文地址</a>。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">~/workspace/test ⌚ 14:02:17</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── accounts      // 实现了高层级的Ethereum账号管理</span><br><span class="line">│   ├── abi       // 实现了Ethereum的ABI(应用程序二进制接口) </span><br><span class="line">│   │   └── bind  // 该包生成Ethereum合约的Go绑定 </span><br><span class="line">│   │       └── backends</span><br><span class="line">│   ├── keystore  // 实现了Secp256k1私钥的加密存储</span><br><span class="line">│   └── usbwallet // 实现了支持USB硬件钱包</span><br><span class="line">├── cmd</span><br><span class="line">│   ├── abigen</span><br><span class="line">│   ├── bootnode  // 该节点为Ethereum发现协议运行一个引导节点 </span><br><span class="line">│   ├── clef</span><br><span class="line">│   ├── cypher    // 是Cypherium的官方客户端命令行 </span><br><span class="line">│   ├── ethkey</span><br><span class="line">│   ├── evm       // 执行EVM代码片段 </span><br><span class="line">│   ├── faucet    // 是以太faucet支持的轻量级客户 </span><br><span class="line">│   ├── p2psim    // 为客户端命令行模拟 HTTP API </span><br><span class="line">│   ├── puppeth   // 是一个命令组装和维护私人网路</span><br><span class="line">│   ├── rlpdump   // 能更好的打印出RLP格式的数据</span><br><span class="line">│   ├── swarm     // bzzhash命令能够更好的计算出swarm哈希树 </span><br><span class="line">│   ├── utils     // 为Go-Ethereum命令提供说明</span><br><span class="line">│   └── wnode</span><br><span class="line">├── common        // 包含一些帮助函数</span><br><span class="line">│   ├── bitutil   // 该包实现快速位操作</span><br><span class="line">│   ├── compiler  // 包装了Solity编译器可执行文件</span><br><span class="line">│   ├── fdlimit</span><br><span class="line">│   ├── hexutil   // 以0x为前缀的十六进制编码 </span><br><span class="line">│   ├── math</span><br><span class="line">│   └── mclock</span><br><span class="line">├── consensus     // 实现了不同以太共识引擎</span><br><span class="line">│   ├── bftcosi</span><br><span class="line">│   │   └── cosi</span><br><span class="line">│   ├── clique    // 实现了权威共识引擎 </span><br><span class="line">│   ├── ethash    // 发动机工作的共识ethash证明 </span><br><span class="line">│   └── misc</span><br><span class="line">├── console</span><br><span class="line">│   └── testdata</span><br><span class="line">├── containers</span><br><span class="line">│   └── docker</span><br><span class="line">│       ├── develop-alpine</span><br><span class="line">│       ├── develop-ubuntu</span><br><span class="line">│       ├── master-alpine</span><br><span class="line">│       └── master-ubuntu</span><br><span class="line">├── contracts</span><br><span class="line">│   ├── chequebook  // ‘支票薄’以太智能合约 </span><br><span class="line">│   └── ens</span><br><span class="line">├── core            // 核心部分，它包含账户、区块、创世块、区块链、transaction、bloom的定义以及区块如何验证、如何加入链以及transaction如何使用vm执行也就是智能合约的执行都在这里完成。 </span><br><span class="line">│   ├── asm         // 汇编和反汇编接口</span><br><span class="line">│   ├── bloombits   // Bloom过滤批量数据</span><br><span class="line">│   ├── rawdb</span><br><span class="line">│   ├── state       // 封装在以太状态树之上的一种缓存结构</span><br><span class="line">│   ├── types       // 以太合约支持的数据类型</span><br><span class="line">│   └── vm          // 以太虚拟机</span><br><span class="line">│       └── runtime // 一种用于执行EVM代码的基本执行模型</span><br><span class="line">├── crypto          // 加密工具包含不限于hash算法、ECC算法等</span><br><span class="line">│   ├── bn256       // 最优的ATE配对在256位Barreto-Naehrig曲线上 </span><br><span class="line">│   │   ├── cloudflare  // 在128位安全级别上的特殊双线性组</span><br><span class="line">│   │   └── google   // 在128位安全级别上的特殊双线性组</span><br><span class="line">│   ├── ecies</span><br><span class="line">│   ├── randentropy</span><br><span class="line">│   ├── secp256k1    // 封装比特币secp256k1的C库</span><br><span class="line">│   └── sha3         // Sha-3固定输出长度散列函数 and 由FIPS-202定义的抖动变量输出长度散列函数</span><br><span class="line">├── dashboard</span><br><span class="line">│   └── assets</span><br><span class="line">│       ├── components</span><br><span class="line">│       └── types</span><br><span class="line">├── docs</span><br><span class="line">├── eth             // 以太坊协议 </span><br><span class="line">│   ├── downloader  // 手动全链同步 </span><br><span class="line">│   ├── fetcher     // 基于块通知的同步 </span><br><span class="line">│   ├── filters     // 用于区块，交易和日志事件的过滤 </span><br><span class="line">│   ├── gasprice    </span><br><span class="line">│   └── tracers     // 收集JavaScript交易追踪 </span><br><span class="line">├── ethclient       // 以太坊RPC AIP客户端 </span><br><span class="line">├── ethdb           // 提供了数据源实现内存以及leveldb，并使用数据源扩展了不同实现，这包含缓存数据源、链数据源，依据于此又封装出读写缓存、异步读写缓存以及链存储相关的数据源实现。定义了如何使用datasource存储block、transaction，换句话说就是block、transaction的存储数据结构</span><br><span class="line">├── ethstats        // 网络统计报告服务 </span><br><span class="line">├── event           // 处理实时事件的费用 </span><br><span class="line">│   └── filter      // 事件过滤</span><br><span class="line">├── internal        </span><br><span class="line">│   ├── build       </span><br><span class="line">│   ├── cmdtest</span><br><span class="line">│   ├── debug       // 调试接口Go运行时调试功能 </span><br><span class="line">│   ├── ethapi      // 常用的以太坊API函数 </span><br><span class="line">│   ├── guide       // 小测试套件，以确保开发指南工作中的代码段正常运行 </span><br><span class="line">│   ├── jsre        // JavaScript执行环境 </span><br><span class="line">│   │   └── deps    // 控制台JavaScript依赖项Go嵌入 </span><br><span class="line">│   └── web3ext     // geth确保web3.js延伸</span><br><span class="line">├── les             // 轻量级Ethereum子协议 </span><br><span class="line">│   └── flowcontrol // 客户端流程控制机制 </span><br><span class="line">├── light           // 客户端实现按需检索能力的状态和链对象</span><br><span class="line">├── log             // 输出日志 </span><br><span class="line">│   └── term</span><br><span class="line">├── metrics         // Coda Hale度量库的Go端口 </span><br><span class="line">│   ├── exp         // 表达式相关操作 </span><br><span class="line">│   ├── influxdb</span><br><span class="line">│   └── librato</span><br><span class="line">├── miner           // 以太坊块创建和挖矿 </span><br><span class="line">├── mobile          // geth的移动端API</span><br><span class="line">├── node            // 设置多维接口节点</span><br><span class="line">├── p2p             // p2p网络协议 </span><br><span class="line">│   ├── discover    // 节点发现协议 </span><br><span class="line">│   ├── discv5      // RLPx v5主题相关的协议 </span><br><span class="line">│   ├── enr         // 实现EIP-778中的以太坊节点记录 </span><br><span class="line">│   ├── nat         // 提供网络端口映射协议的权限 </span><br><span class="line">│   ├── netutil     // 网络包拓展 </span><br><span class="line">│   ├── protocols   // p2p拓展 </span><br><span class="line">│   └── simulations // 实现模拟p2p网络 </span><br><span class="line">├── params</span><br><span class="line">├── rlp             // RLP系列化格式 </span><br><span class="line">├── rpc             // 通过网络或者I/O链接来访问接口</span><br><span class="line">├── signer</span><br><span class="line">│   ├── core</span><br><span class="line">│   ├── rules</span><br><span class="line">│   │   └── deps</span><br><span class="line">│   └── storage</span><br><span class="line">├── swarm</span><br><span class="line">│   ├── api</span><br><span class="line">│   │   ├── client</span><br><span class="line">│   │   └── http</span><br><span class="line">│   ├── bmt</span><br><span class="line">│   ├── dev</span><br><span class="line">│   ├── fuse</span><br><span class="line">│   ├── grafana_dashboards</span><br><span class="line">│   ├── log</span><br><span class="line">│   ├── metrics</span><br><span class="line">│   ├── multihash</span><br><span class="line">│   ├── network</span><br><span class="line">│   ├── pot</span><br><span class="line">│   ├── pss</span><br><span class="line">│   ├── services</span><br><span class="line">│   ├── state</span><br><span class="line">│   ├── storage</span><br><span class="line">│   └── testutil</span><br><span class="line">├── tests             // 以太坊JSON测试 </span><br><span class="line">├── trie              // Merkle Patricia树实现</span><br><span class="line">├── vendor</span><br><span class="line">│   ├── github.com</span><br><span class="line">│   ├── gopkg.in</span><br><span class="line">│   │   └── check.v1  // Go更深的测试 </span><br><span class="line">└── whisper</span><br><span class="line">    ├── mailserver</span><br><span class="line">    ├── shhclient</span><br><span class="line">    ├── whisperv5</span><br><span class="line">    └── whisperv6</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/blockchain/cypherium-dir-description/&quot;&gt;https://lilyssh.cn/blockchain/cypherium-dir-description/&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;go-cypherium&lt;br&gt;本篇为转发，只做了下样式整理，&lt;a href=&quot;https://blog.csdn.net/jiang_xinxing/article/details/80249981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://lilyssh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>web3.js 如何修改/添加命令</title>
    <link href="https://lilyssh.cn/blockchain/geth-web3-update-command/"/>
    <id>https://lilyssh.cn/blockchain/geth-web3-update-command/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.407Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/blockchain/geth-web3-update-command/">https://lilyssh.cn/blockchain/geth-web3-update-command/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以太坊的js交互是靠<a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>调用的。<br>改完后，需要打包，放到<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">Go Ethereum</a>里测试,以下就是修改命令过程说明。<br><a id="more"></a></p><h2 id="一、eth-改为-cph"><a href="#一、eth-改为-cph" class="headerlink" title="一、eth 改为 cph"></a>一、eth 改为 cph</h2><ol><li>修改 <code>web3.js/lib/web3.js</code> 文件中 <code>Web3</code>方法。<code>web3.js</code>是基础命令定义处。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.eth = new Eth(this);  //修改前</span><br><span class="line">this.cph = new Eth(this);  //修改后</span><br></pre></td></tr></table></figure><ol start="2"><li>修改<a href="#internal">go-cypherium/internal/web3ext/web3ext.go</a> 文件中<code>Eth_JS</code>常量定义处。<code>web3ext.go</code>是扩展命令定义处。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const Eth_JS = `</span><br><span class="line">web3._extend(&#123;</span><br><span class="line">property: &apos;eth&apos;,  //修改前</span><br><span class="line">        property: &apos;cph&apos;,  //修改后</span><br></pre></td></tr></table></figure><ol start="3"><li>修改<code>go-cypherium/console/console.go</code>中，init方法。此处为web3.eth命令起个简略别名eth。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flatten := &quot;var eth = web3.eth; var personal = web3.personal; &quot;  //修改前</span><br><span class="line">flatten := &quot;var cph = web3.cph; var personal = web3.personal; &quot;  //修改后</span><br></pre></td></tr></table></figure></li></ol><p>到此，修改完成！</p><h2 id="二、eth-getBlock-n-改为-eth-getTxBlock-n"><a href="#二、eth-getBlock-n-改为-eth-getTxBlock-n" class="headerlink" title="二、eth.getBlock(n) 改为 eth.getTxBlock(n)"></a>二、eth.getBlock(n) 改为 eth.getTxBlock(n)</h2><p><a href="id:internal" target="_blank" rel="noopener">以太坊源码分析 internal包简介</a></p><h2 id="ethapi-api包分析"><a href="#ethapi-api包分析" class="headerlink" title="ethapi/api包分析"></a>ethapi/api包分析</h2><p>ethapi/api包主要是进入js的命令行界面后，输入的命令实现部分。<br><br>js的命令实现在ethapi/api和node/api中。目前一共有三种api的命令。<br><br>(1)第一种是admin相关的命令，这个是通过安全的RPC通道实现的。其结构体为PrivateAdminAPI<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PrivateAdminAPI is the collection of administrative API methods exposed only</span><br><span class="line">// over a secure RPC channel.</span><br><span class="line">type PrivateAdminAPI struct &#123;</span><br><span class="line">    node *Node // Node interfaced by this API</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)第二种是personal相关的命令，主要是负责账户管理相关命令，可以lock和unlock账户。其结构体为PrivateAccountAPI<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// PrivateAccountAPI provides an API to access accounts managed by this node.</span><br><span class="line">// It offers methods to create, (un)lock en list accounts. Some methods accept</span><br><span class="line">// passwords and are therefore considered private by default.</span><br><span class="line">type PrivateAccountAPI struct &#123;</span><br><span class="line">    am *accounts.Manager</span><br><span class="line">    nonceLock *AddrLocker</span><br><span class="line">    b Backend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(3)第三种是eth相关的命令，主要是可以操作区块上的相关命令。其结构体为PublicBlockChainAPI<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// PublicBlockChainAPI provides an API to access the Ethereum blockchain.</span><br><span class="line">// It offers only methods that operate on public data that is freely available to anyone.</span><br><span class="line">type PublicBlockChainAPI struct &#123;</span><br><span class="line">    b Backend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="otto包"><a href="#otto包" class="headerlink" title="otto包"></a>otto包</h2><p>以太坊的命令是通过在js虚拟机上来实现命令的。而在go语言中，有第三方的otto包，可以直接在go语言中实现js命令。而以太坊代码则使用了otto包来实现搭建js命令。<br><br>在otto包中，set方法是设置变量的值，get方法是获取变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Set the property of the given name to the given value.</span><br><span class="line">func (self Object) Set(name string, value interface&#123;&#125;)</span><br><span class="line">// Get the value of the property with the given name.</span><br><span class="line">func (self Object) Get(name string) (Value, error)</span><br></pre></td></tr></table></figure></p><p>Compile是根据输入的路径对js的代码进行编译，返回变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Compile will parse the given source and return a Script value or nil and</span><br><span class="line">// an error if there was a problem during compilation.</span><br><span class="line">func (self *Otto) Compile(filename string, src interface&#123;&#125;) (*Script, error)</span><br></pre></td></tr></table></figure></p><p>Run方法会运行相关的js代码，如果有返回值的话会返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Run will run the given source (parsing it first if necessary), returning the resulting value and error (if any)</span><br><span class="line">func (self Otto) Run(src interface&#123;&#125;) (Value, error)</span><br></pre></td></tr></table></figure></p><h2 id="如何编写自己的以太坊命令"><a href="#如何编写自己的以太坊命令" class="headerlink" title="如何编写自己的以太坊命令"></a>如何编写自己的以太坊命令</h2><p>接上篇ethapi.api-analysis分析，如果我们需要在相关模块添加相关命令，首先我们需要找到相关命令所对应的api结构体。<br><br>各个命令对应的结构体，包的位置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">admin  PrivateAdminAPI,PublicAdminAPI  node/api</span><br><span class="line">debug  PrivateDebugAPI eth/api</span><br><span class="line">eth    PublicBlockChainAPI ethapi/api</span><br><span class="line">miner  PrivateMinerAPI eth/api</span><br><span class="line">net    PublicNetAPI    ethapi/api</span><br><span class="line">personal   PrivateAccountAPI   ethapi/api</span><br><span class="line">txpool PublicTxPoolAPI ethapi/api</span><br><span class="line">rpc    所有可调用包集合</span><br><span class="line">web3   所有命令集合</span><br></pre></td></tr></table></figure></p><p>假设我们需要在personal包中添加一个命令，那么我们就在PrivateAccountAPI中添加一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s *PrivateAccountAPI) TestMethod() &#123;</span><br><span class="line">fmt.Print(&quot;TestMethod&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来到internal/web3ext/web3ext.go中，找到personal命令集合，然后添加一条自己的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Personal_JS = `</span><br><span class="line">web3._extend(</span><br><span class="line">methods: [</span><br><span class="line">        new web3._extend.Method(&#123;</span><br><span class="line">            name : &apos;testMethod&apos;,</span><br><span class="line">            call : &apos;personal_testMethod&apos;</span><br><span class="line">        &#125;), //our method</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>最后到internal/jsre/deps/web3.js中，找到personal方法的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Personal(web3) &#123;</span><br><span class="line">this._requestManager = web3._requestManager;</span><br><span class="line"></span><br><span class="line">var self = this;</span><br><span class="line"></span><br><span class="line">methods().forEach(function(method) &#123;</span><br><span class="line">method.attachToObject(self);</span><br><span class="line">method.setRequestManager(self._requestManager);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">properties().forEach(function(p) &#123;</span><br><span class="line">p.attachToObject(self);</span><br><span class="line">p.setRequestManager(self._requestManager);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">var methods = function () &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后再methods中添加你定义的方法名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var methods = function () &#123;</span><br><span class="line">var testMethod = new Method(&#123;</span><br><span class="line">name : &apos;testMethod&apos;,</span><br><span class="line">call : &apos;personal_testMethod&apos;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>并在最后的return中添加你的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">return [</span><br><span class="line">newAccount,</span><br><span class="line">testMethod, //our method</span><br><span class="line">importRawKey,</span><br><span class="line">unlockAccount,</span><br><span class="line">ecRecover,</span><br><span class="line">sign,</span><br><span class="line">sendTransaction,</span><br><span class="line">lockAccount</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>这之后在启动命令行，我们就可以调用我们的方法了。结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.testMethod()</span><br><span class="line">TestMethodnull</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/blockchain/geth-web3-update-command/&quot;&gt;https://lilyssh.cn/blockchain/geth-web3-update-command/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以太坊的js交互是靠&lt;a href=&quot;https://github.com/ethereum/web3.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;web3.js&lt;/a&gt;调用的。&lt;br&gt;改完后，需要打包，放到&lt;a href=&quot;https://github.com/ethereum/go-ethereum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go Ethereum&lt;/a&gt;里测试,以下就是修改命令过程说明。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://lilyssh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>ansible 使用亚马逊云服务(AWS)密钥文件 xx.pem同时操纵多台机子</title>
    <link href="https://lilyssh.cn/linux/ansible-aws-pem/"/>
    <id>https://lilyssh.cn/linux/ansible-aws-pem/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2019-05-11T05:07:50.827Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://blog.csdn.net/lilyssh/article/details/82911903" target="_blank" rel="noopener">https://blog.csdn.net/lilyssh/article/details/82911903</a>  </p><h2 id="一、安装ansible"><a href="#一、安装ansible" class="headerlink" title="一、安装ansible"></a>一、安装<a href="https://www.ansible.com" target="_blank" rel="noopener">ansible</a></h2><ol><li>安装<a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip</a>包管理工具,先下载安装脚本<code>get-pip.py</code>。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="2"><li>执行安装脚本。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure><p>验证下是否安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --version</span><br></pre></td></tr></table></figure></p><ol start="3"><li>安装 ansible  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install ansible</span><br></pre></td></tr></table></figure><p>验证下是否安装成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible --version</span><br></pre></td></tr></table></figure></p><h2 id="二、-配置ansible。"><a href="#二、-配置ansible。" class="headerlink" title="二、 配置ansible。"></a>二、 配置<a href="https://www.ansible.com" target="_blank" rel="noopener">ansible</a>。</h2><p>在<code>/etc</code>下新建文件夹<code>ansible</code>，在<code>/etc/ansible</code>下创建<code>hosts</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[aws]</span><br><span class="line">13.59.244.124ansible_ssh_private_key_file=~/cypherium_internal.pem</span><br><span class="line">18.216.16.200   ansible_ssh_private_key_file=~/cypherium_internal.pem</span><br></pre></td></tr></table></figure></p><p>aws是自定义的服务器组名。</p><h2 id="三、使用ansible。"><a href="#三、使用ansible。" class="headerlink" title="三、使用ansible。"></a>三、使用<a href="https://www.ansible.com" target="_blank" rel="noopener">ansible</a>。</h2><p><code>ping</code>一下分组中的机子，用<code>ping</code>模块， <code>-u 用户名</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible aws -m ping -u ubuntu</span><br></pre></td></tr></table></figure></p><p><img src="https://resource.lilyssh.cn/pic/ansible_ping.png" alt><br><code>ls</code> 一下分组中的机子，用<code>shell</code>模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible aws -m shell -a &quot;ls&quot; -u ubuntu</span><br></pre></td></tr></table></figure></p><p><img src="https://resource.lilyssh.cn/pic/ansible_ls.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://blog.csdn.net/lilyssh/article/details/82911903&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lilyssh/article/details/82911903&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;一、安装ansible&quot;&gt;&lt;a href=&quot;#一、安装ansible&quot; class=&quot;headerlink&quot; title=&quot;一、安装ansible&quot;&gt;&lt;/a&gt;一、安装&lt;a href=&quot;https://www.ansible.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ansible&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装&lt;a href=&quot;https://pip.pypa.io/en/stable/installing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pip&lt;/a&gt;包管理工具,先下载安装脚本&lt;code&gt;get-pip.py&lt;/code&gt;。  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://lilyssh.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://lilyssh.cn/tags/Linux/"/>
    
      <category term="Ansible" scheme="https://lilyssh.cn/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>Go Ethereum 以太坊 web3.js 打包编译发布过程</title>
    <link href="https://lilyssh.cn/blockchain/geth-web3-gulp-bindata-/"/>
    <id>https://lilyssh.cn/blockchain/geth-web3-gulp-bindata-/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.406Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://blog.csdn.net/lilyssh/article/details/82911406" target="_blank" rel="noopener">https://blog.csdn.net/lilyssh/article/details/82911406</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以太坊的js交互是靠<a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>调用的。<br>改完后，需要打包，放到<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">Go Ethereum</a>里测试,以下就是打包编译过程说明。<br>web3.js版本：v0.20.6。<br><a id="more"></a></p><ol><li>安装cnpm</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>web3.js</code>的根路径下 安装<code>web3.js</code>的依赖</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm install</span><br></pre></td></tr></table></figure><ol start="3"><li>安装<code>gulp</code>打包命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp -g</span><br></pre></td></tr></table></figure><ol start="4"><li>在<code>web3.js</code>的根路径下 执行<code>gulp</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure><ol start="5"><li>把<code>dist/web3.js</code>文件拷贝到项目中</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp dist/web3.js ../go-cypherium/internal/jsre/deps</span><br></pre></td></tr></table></figure><ol start="6"><li>安装<code>go-bindata</code>(我是在~目录下执行的)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/jteeuwen/go-bindata/...</span><br></pre></td></tr></table></figure><ol start="7"><li>复制 go-bindata文件 到 go的安装目录的bin下。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/go/bin/go-bindata  ~/install/go/bin</span><br></pre></td></tr></table></figure><ol start="8"><li>在cypherium_private/go-cypherium/internal/jsre/deps下执行deps.go的倒数第二行,会看到bindata.go已变蓝色，大功告成！</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go-bindata -nometadata -pkg deps -o bindata.go bignumber.js web3.js</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://blog.csdn.net/lilyssh/article/details/82911406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lilyssh/article/details/82911406&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以太坊的js交互是靠&lt;a href=&quot;https://github.com/ethereum/web3.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;web3.js&lt;/a&gt;调用的。&lt;br&gt;改完后，需要打包，放到&lt;a href=&quot;https://github.com/ethereum/go-ethereum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go Ethereum&lt;/a&gt;里测试,以下就是打包编译过程说明。&lt;br&gt;web3.js版本：v0.20.6。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://lilyssh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>Cypherium 同步区块测试操作步骤</title>
    <link href="https://lilyssh.cn/blockchain/cypherium-test-sync-block/"/>
    <id>https://lilyssh.cn/blockchain/cypherium-test-sync-block/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.405Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/blockchain/cypherium-test-sync-block/">https://lilyssh.cn/blockchain/cypherium-test-sync-block/</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Cypherium 同步区块链测试步骤。以下步骤适用于同一台机子测试。如果使用两台电脑测试，则有关第二节点的操作在另一台机子上执行即可。以下命令请在<code>cypherium_private/go-cypherium</code>路径下执行。<br><a id="more"></a></p><ol><li>创建test文件夹,test中目录结构如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/workspace/test ⌚ 14:02:17</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── genesis.json</span><br><span class="line">├── group.toml</span><br><span class="line">├── node_01</span><br><span class="line">│   ├── data</span><br><span class="line">└── node_02</span><br><span class="line">    ├── data</span><br></pre></td></tr></table></figure><ol start="2"><li>清理  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><ol start="3"><li>编译  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make cypher</span><br></pre></td></tr></table></figure><ol start="4"><li>生成节点信息  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher setup</span><br></pre></td></tr></table></figure><p>需要输入 ip：端口，用于测试使用kyber的Ed25519算法生成<code>public.toml</code>和<code>private.toml</code>，保存在默认路径。目前没做ip发现，所以需手动拼接公钥<code>~/Library/Application\ Support/cypher/public.toml</code>(Mac默认路径)，用于模拟测试。节点名字可自定义，如node_01_name。<br><img src="https://resource.lilyssh.cn/pic/cypher%20setup_.png" alt></p><ol start="5"><li><p>同理，再生成第二个节点。</p></li><li><p>把第一、二个节点的public.toml，拼接到~/workspace/test/group.toml中。</p></li></ol><p><img src="https://resource.lilyssh.cn/pic/group.toml.png" alt></p><ol start="7"><li>初始化 两个节点的创世区块。  </li></ol><p>第一个节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --datadir &quot;~/workspace/test/node_01/data&quot; init ~/workspace/test/genesis.json</span><br></pre></td></tr></table></figure></p><p>第二个节点:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --datadir &quot;~/workspace/test/node_02/data&quot; init ~/workspace/test/genesis.json</span><br></pre></td></tr></table></figure></p><p>genesis.json中内容可参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">        &quot;chainId&quot;: 123666,</span><br><span class="line">        &quot;homesteadBlock&quot;: 0,</span><br><span class="line">        &quot;eip155Block&quot;: 0,</span><br><span class="line">        &quot;eip158Block&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">  &quot;alloc&quot;      : &#123;&#125;,</span><br><span class="line">  &quot;coinbase&quot;   : &quot;0x0000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;difficulty&quot; : &quot;0x20000&quot;,</span><br><span class="line">  &quot;extraData&quot;  : &quot;&quot;,</span><br><span class="line">  &quot;gasLimit&quot;   : &quot;0x2fefd8&quot;,</span><br><span class="line">  &quot;nonce&quot;      : &quot;0x0000000000000042&quot;,</span><br><span class="line">  &quot;mixhash&quot;    : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;parentHash&quot; : &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,</span><br><span class="line">  &quot;timestamp&quot;  : &quot;0x00&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="8"><li>启动第一个节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --onetdir ~/workspace/test/node_01/private.toml --datadir ~/workspace/test/node_01/data --publickeydir ~/workspace/test/group.toml --networkid 123666 --port 7010 --rpcport 8510 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcapi eth,web3,personal --verbosity 5 2&gt; ~/workspace/test/node_01/output2.log</span><br></pre></td></tr></table></figure><ol start="9"><li>启动第一个节点的js交互窗口(用上一步成的ipc文件)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher attach ~/workspace/test/node_01/data/cypher.ipc</span><br></pre></td></tr></table></figure><ol start="10"><li>启动第二个节点。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher --onetdir ~/workspace/test/node_02/private.toml --datadir ~/workspace/test/node_02/data --publickeydir ~/workspace/test/group.toml --networkid 123666 --port 7020 --rpcport 8520 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcapi eth,web3,personal --verbosity 5 2&gt; ~/workspace/test/node_02/output2.log</span><br></pre></td></tr></table></figure><ol start="11"><li>启动第二个节点的js交互窗口(用上一步成的ipc文件)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/bin/cypher attach ~/workspace/test/node_02/data/cypher.ipc</span><br></pre></td></tr></table></figure><p><img src="https://resource.lilyssh.cn/pic/attach%20node_.jpg" alt></p><ol start="12"><li>从此步骤开始，都将在js交互涌窗口执行。查看第一个节点的信息。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.nodeInfo</span><br></pre></td></tr></table></figure><ol start="13"><li>在第二个节点中，创建用户，保存挖矿奖励。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.newAccount(&quot;password&quot;)</span><br></pre></td></tr></table></figure><ol start="14"><li>在第二个节点中，加入第一个节点。就是把cnode中的内容粘进addPeer中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin.addPeer(&quot;cnode&quot;)</span><br></pre></td></tr></table></figure><ol start="15"><li>在第一个节点中，验证一下是否已加入。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net</span><br></pre></td></tr></table></figure><ol start="16"><li>主节点调用开始同步命令，从交易池里取tx执行，并打包生成txBlock，发给其他委员会成员做bftcosi共识。会看到两个节点的信息都在滚动。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftcosi.start()</span><br></pre></td></tr></table></figure><ol start="17"><li>停止共识。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bftcosi.stop()</span><br></pre></td></tr></table></figure><ol start="18"><li>查看下两个节点的区块数量是否相同。</li></ol><p><img src="https://resource.lilyssh.cn/pic/txBlockNumber.png" alt></p><ol start="19"><li>(不时需要)解锁账户</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personal.unlockAccount(&quot;需解锁账户&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://resource.lilyssh.cn/pic/unlockAccount.png" alt></p><ol start="20"><li>查看交易池状态，pending为待确认的交易数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txpool.status</span><br></pre></td></tr></table></figure></li></ol><p>会显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  pending: 0,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="19"><li>退出：</li></ol><p><img src="https://resource.lilyssh.cn/pic/killall.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/blockchain/cypherium-test-sync-block/&quot;&gt;https://lilyssh.cn/blockchain/cypherium-test-sync-block/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Cypherium 同步区块链测试步骤。以下步骤适用于同一台机子测试。如果使用两台电脑测试，则有关第二节点的操作在另一台机子上执行即可。以下命令请在&lt;code&gt;cypherium_private/go-cypherium&lt;/code&gt;路径下执行。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://lilyssh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="Cypherium" scheme="https://lilyssh.cn/tags/Cypherium/"/>
    
  </entry>
  
  <entry>
    <title>Go Ethereum 以太坊 web3.js 控制台 调试</title>
    <link href="https://lilyssh.cn/blockchain/geth-web3-javascript-debug/"/>
    <id>https://lilyssh.cn/blockchain/geth-web3-javascript-debug/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.407Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://blog.csdn.net/lilyssh/article/details/82911363" target="_blank" rel="noopener">https://blog.csdn.net/lilyssh/article/details/82911363</a>  </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近要根据以太坊，做个数字货币，需要修改一些命令，就看了一下<a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a>。<br>每次改完，都需要打包，放到<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">Go Ethereum</a>里测试，非常麻烦，就研究了一波怎么调试和怎么使用测试用例。<br><a id="more"></a></p><h1 id="一、从官网寻找测试方法"><a href="#一、从官网寻找测试方法" class="headerlink" title="一、从官网寻找测试方法"></a>一、从官网寻找测试方法</h1><p>1、从web3.js的github地址页面，看<a href="https://github.com/ethereum/web3.js/blob/develop/README.md" target="_blank" rel="noopener">README.md</a>，能看到测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure></p><p>2、从<a href="https://github.com/ethereum/web3.js/blob/develop/package.json" target="_blank" rel="noopener">package.json</a>中可以看到<code>npm test</code>的测试方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;gulp&quot;,</span><br><span class="line">    &quot;watch&quot;: &quot;gulp watch&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;jshint *.js lib&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha; jshint *.js lib&quot;,</span><br><span class="line">    &quot;test-coveralls&quot;: &quot;istanbul cover _mocha -- -R spec &amp;&amp; cat coverage/lcov.info | coveralls --verbose&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>看到web3.js是用<code>mocha</code>测试的。  </p><h1 id="二、使用WebStorm调试web3-js"><a href="#二、使用WebStorm调试web3-js" class="headerlink" title="二、使用WebStorm调试web3.js"></a>二、使用<a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a>调试<a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3.js</a></h1><p>1、点击<code>Add Configuration</code>，添加一个测试配置。<br><img src="https://resource.lilyssh.cn/pic/add%20configuration.png" alt><br>2、选择Mocha：<br><img src="https://resource.lilyssh.cn/pic/add%20mocha.png" alt><br>3、配置mocha：<br><img src="https://resource.lilyssh.cn/pic/config%20mocha.png" alt><br>4、debug：<br><img src="https://resource.lilyssh.cn/pic/mocha%20debug.png" alt></p><p>接下来就可以愉快的调试啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://blog.csdn.net/lilyssh/article/details/82911363&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lilyssh/article/details/82911363&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近要根据以太坊，做个数字货币，需要修改一些命令，就看了一下&lt;a href=&quot;https://github.com/ethereum/web3.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;web3.js&lt;/a&gt;。&lt;br&gt;每次改完，都需要打包，放到&lt;a href=&quot;https://github.com/ethereum/go-ethereum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go Ethereum&lt;/a&gt;里测试，非常麻烦，就研究了一波怎么调试和怎么使用测试用例。&lt;br&gt;
    
    </summary>
    
      <category term="Blockchain" scheme="https://lilyssh.cn/categories/Blockchain/"/>
    
    
      <category term="Blockchain" scheme="https://lilyssh.cn/tags/Blockchain/"/>
    
      <category term="区块链" scheme="https://lilyssh.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="以太坊" scheme="https://lilyssh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>mysql 8.0 主从复制 基本配置</title>
    <link href="https://lilyssh.cn/mysql/1-mysql-replication/"/>
    <id>https://lilyssh.cn/mysql/1-mysql-replication/</id>
    <published>2018-06-18T16:00:00.000Z</published>
    <updated>2019-05-03T11:20:49.418Z</updated>
    
    <content type="html"><![CDATA[<p>转载请标注原文地址：<a href="https://lilyssh.cn/mysql/1-mysql-replication/">https://lilyssh.cn/mysql/1-mysql-replication/</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MySQL主从复制可实现数据的多处自动备份。不仅可以加强数据的安全性，通过实现读写分离还能提升数据库的负载性能。<br><a id="more"></a></p><h1 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h1><p><img src="http://p8wysinsm.bkt.clouddn.com/mysql_replication.jpeg" alt> MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="主服务器："><a href="#主服务器：" class="headerlink" title="主服务器："></a>主服务器：</h2><ul><li>开启二进制日志</li><li>配置唯一的server-id</li><li>获得master二进制日志文件名及位置</li><li>创建一个用于slave和master通信的用户账号<h2 id="从服务器："><a href="#从服务器：" class="headerlink" title="从服务器："></a>从服务器：</h2></li><li>配置唯一的server-id</li><li>使用master分配的用户账号读取master二进制日志</li><li>启用slave服务</li></ul><p>具体实现过程如下：<br>一、主数据库master修改：<br>1.修改mysql配置</p><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log_bin=mysql-bin #开启二进制日志,mysql-bin是二进制日志文件的名称，可自定义命名。</span><br><span class="line">server-id=1 #设置server-id</span><br></pre></td></tr></table></figure></p><p>2.重启mysql，创建用于同步的用户账号</p><p>打开mysql会话shell&gt;mysql -hlocalhost -uname -ppassword</p><p>创建用户并授权：用户：repl 密码：slavepass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &apos;repl&apos;@&apos;123.57.44.85&apos; IDENTIFIED BY &apos;slavepass&apos;;#创建用户</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &apos;repl&apos;@&apos;123.57.44.85&apos;;#分配权限</span><br><span class="line">mysql&gt;flush privileges;   #刷新权限</span><br></pre></td></tr></table></figure></p><p>3.查看master状态，记录二进制文件名(mysql-bin.000003)和位置(73)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; SHOW MASTER STATUS;</span><br></pre></td></tr></table></figure><table><thead><tr><th>File</th><th>Position</th><th>Binlog_Do_DB</th><th>Binlog_Ignore_DB</th><th>Executed_Gtid_Set</th></tr></thead><tbody><tr><td>mysql-bin.000004</td><td>155</td><td></td><td></td></tr></tbody></table><p>二、从服务器slave修改：<br>1.修改mysql配置<br>同样找到my.cnf配置文件，添加server-id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2 #设置server-id，必须唯一</span><br></pre></td></tr></table></figure></p><p>2.重启mysql，打开mysql会话，执行同步SQL语句(需要主服务器主机名，登陆凭据，二进制文件的名称和位置)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">    -&gt;     MASTER_HOST=&apos;192.168.0.110&apos;,</span><br><span class="line">    -&gt;     MASTER_USER=&apos;repl&apos;,</span><br><span class="line">    -&gt;     MASTER_PASSWORD=&apos;slavepass&apos;,</span><br><span class="line">    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000003&apos;,</span><br><span class="line">    -&gt;     MASTER_LOG_POS=73;</span><br></pre></td></tr></table></figure></p><p>3.启动slave同步进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;start slave;</span><br></pre></td></tr></table></figure></p><p>4.查看slave状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 182.92.172.80</span><br><span class="line">                  Master_User: rep1</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000013</span><br><span class="line">          Read_Master_Log_Pos: 11662</span><br><span class="line">               Relay_Log_File: mysqld-relay-bin.000022</span><br><span class="line">                Relay_Log_Pos: 11765</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000013</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请标注原文地址：&lt;a href=&quot;https://lilyssh.cn/mysql/1-mysql-replication/&quot;&gt;https://lilyssh.cn/mysql/1-mysql-replication/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;MySQL主从复制可实现数据的多处自动备份。不仅可以加强数据的安全性，通过实现读写分离还能提升数据库的负载性能。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://lilyssh.cn/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://lilyssh.cn/tags/MySQL/"/>
    
  </entry>
  
</feed>
